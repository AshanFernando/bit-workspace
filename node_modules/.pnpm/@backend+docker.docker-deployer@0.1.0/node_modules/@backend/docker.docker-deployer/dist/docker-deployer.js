import { Logger } from "@teambit/logger";
import path, { join } from "node:path";
import { readdir, mkdir, readlink, symlink, copyFile } from "node:fs/promises";
import Docker from "dockerode";
export class DockerDeploy {
    constructor(options) {
        this.options = options;
    }
    static deploy(options) {
        const dockerDeployer = new DockerDeploy(options);
        return async (deployContext) => {
            await dockerDeployer.deploy(deployContext);
        };
    }
    async deploy(context) {
        const { publicDir, capsule, pipeName, laneId, appComponent } = context;
        const logger = new Logger(`${appComponent.displayName}:docker-${laneId}`);
        const docker = this.docker;
        const buildOptions = this.options.buildOptions || {};
        const pushOptions = this.options.pushOptions || {};
        const template = typeof this.options.dockerfileTemplate === "string"
            ? null
            : this.options.dockerfileTemplate;
        const tag = this.getTag(appComponent, pipeName);
        logger.console(`[docker] building image ${tag}`);
        if (!publicDir)
            throw new Error("publicDir is required");
        logger.console(`[docker] building image at ${capsule.path} with public dir ${publicDir}`);
        if (this.options.copyNodeModules || template?.copyNodeModules) {
            // Copy node_modules to the public dir
            await this.copyDirectory(join(capsule.path, "..", "node_modules"), join(capsule.path, publicDir, "node_modules"));
        }
        logger.console(`[docker] building image ${tag}`);
        if (template) {
            logger.console("[docker] using custom Dockerfile template");
            const relativePublicDir = path.isAbsolute(publicDir)
                ? path.relative(capsule.path, publicDir)
                : publicDir;
            const dockerfile = await template.generate({
                capsulePath: capsule.path,
                publicDir: relativePublicDir,
                appName: appComponent.id.name,
                entryFile: this.options.entryFile,
            });
            capsule.fs.writeFileSync("Dockerfile", dockerfile);
        }
        const buildStream = await docker.buildImage({
            context: capsule.path,
            src: ["."],
        }, {
            dockerfile: template
                ? "Dockerfile"
                : this.options.dockerfileTemplate,
            t: tag,
            ...buildOptions,
        });
        buildStream.on("data", (data) => {
            try {
                const output = JSON.parse(data.toString());
                if (output.stream) {
                    const cleanOutput = output.stream.trim();
                    if (cleanOutput) {
                        logger.console(cleanOutput);
                    }
                }
            }
            catch (err) {
                logger.error("Error parsing docker build output:", err.toString());
            }
        });
        buildStream.on("error", (err) => {
            logger.error(err.toString());
        });
        await new Promise((resolve, reject) => {
            docker.modem.followProgress(buildStream, (err, res) => {
                if (err) {
                    reject(err);
                }
                resolve(res);
            });
        });
        logger.console(`[docker] pushing image ${tag}`);
        const pushStream = await docker.getImage(tag).push({
            ...pushOptions,
        });
        pushStream.on("data", (data) => {
            try {
                const output = JSON.parse(data.toString());
                if (output.status) {
                    logger.console(`${output.status}: ${output.progress || ""}`);
                }
                else if (output.error) {
                    logger.error(output.error);
                }
            }
            catch (err) {
                logger.error("Error parsing docker push output:", err.toString());
            }
        });
        pushStream.on("error", (err) => {
            logger.error(err.toString());
        });
        await new Promise((resolve, reject) => {
            docker.modem.followProgress(pushStream, (err, res) => {
                if (err) {
                    reject(err);
                }
                resolve(res);
            });
        });
        logger.console(`[docker] image ${tag} pushed`);
    }
    getTag(appComponent, pipeName) {
        const { org, tag, latest, version } = this.options;
        const appName = appComponent.id.name;
        const appOrg = appComponent.id.scope;
        const appVersion = version ??
            (pipeName === "snap"
                ? appComponent.id.version.slice(0, 7)
                : appComponent.id.version);
        if (tag)
            return tag;
        if (latest) {
            return `${org ?? appOrg}/${appName}:latest`;
        }
        if (org) {
            return `${org}/${appName}:${appVersion}`;
        }
        return `${appOrg}/${appName}:${appVersion}`;
    }
    /**
     * Recursively copy a directory but change the symlinks to be relative to the new destination
     * @param src
     * @param dest
     */
    async copyDirectory(src, dest) {
        try {
            await mkdir(dest, { recursive: true });
            const entries = await readdir(src, { withFileTypes: true });
            for (const entry of entries) {
                const srcPath = path.join(src, entry.name);
                const destPath = path.join(dest, entry.name);
                if (entry.isSymbolicLink()) {
                    const link = await readlink(srcPath);
                    const resolvedLink = path.resolve(path.dirname(srcPath), link);
                    // Calculate the relative path from the original source directory to the resolved link
                    const originalRelativeLink = path.relative(src, resolvedLink);
                    // Now resolve this relative path against the new destination directory
                    const newTarget = path.resolve(dest, originalRelativeLink);
                    const relativeLink = path.relative(path.dirname(destPath), newTarget);
                    await symlink(relativeLink, destPath);
                }
                else if (entry.isDirectory()) {
                    await this.copyDirectory(srcPath, destPath);
                }
                else {
                    await copyFile(srcPath, destPath);
                }
            }
        }
        catch (error) {
            console.error("Error copying directory:", error);
        }
    }
    get docker() {
        return new Docker();
    }
}
//# sourceMappingURL=docker-deployer.js.map