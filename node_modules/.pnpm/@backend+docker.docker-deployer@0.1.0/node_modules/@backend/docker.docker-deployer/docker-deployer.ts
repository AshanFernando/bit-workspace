import type { AppDeployContext } from "@teambit/application";
import type { Component } from "@teambit/component";
import type { PipeName } from "@teambit/builder";
import { Logger } from "@teambit/logger";
import path, { join } from "node:path";
import { readdir, mkdir, readlink, symlink, copyFile } from "node:fs/promises";
import Docker from "dockerode";
import type { DockerFileTemplate } from "./template.js";

export type DockerDeployerOptions = {
	/**
	 * if true, the image will be tagged as latest
	 */
	latest?: boolean;
	/**
	 * the organization to use for the image tag (e.g. my-org/my-app)
	 */
	org?: string;
	/**
	 * override tag of the image
	 */
	tag?: string;
	/**
	 * the version to append to the tag
	 */
	version?: string;
	buildOptions?: Docker.ImageBuildOptions;
	pushOptions?: Docker.ImagePushOptions;
	/**
	 * if true, node_modules will be copied to the public dir
	 * @default false
	 */
	copyNodeModules?: boolean;

	/**
	 * The template to use for the Dockerfile
	 * Can be a custom template or a Dockerfile relative path.
	 * @example
	 * ```ts
	 * dockerfileTemplate: new NodeDockerFile()
	 * ```
	 */
	dockerfileTemplate: DockerFileTemplate | string;
	/**
	 * Entry file for the app, used in the Dockerfile
	 * @example
	 * ```ts
	 * entryFile: "node-app.cjs"
	 * ```
	 */
	entryFile: string;
};

export type DeployContext = {
	publicDir?: string;
	metadata?: Record<string, unknown>;
} & AppDeployContext;

export class DockerDeploy {
	constructor(readonly options: DockerDeployerOptions) {}

	static deploy(options: DockerDeployerOptions) {
		const dockerDeployer = new DockerDeploy(options);
		return async (deployContext: DeployContext): Promise<void> => {
			await dockerDeployer.deploy(deployContext);
		};
	}

	async deploy(context: DeployContext): Promise<void> {
		const { publicDir, capsule, pipeName, laneId, appComponent } = context;
		const logger = new Logger(`${appComponent.displayName}:docker-${laneId}`);
		const docker = this.docker;

		const buildOptions = this.options.buildOptions || {};
		const pushOptions = this.options.pushOptions || {};
		const template =
			typeof this.options.dockerfileTemplate === "string"
				? null
				: this.options.dockerfileTemplate;

		const tag = this.getTag(appComponent, pipeName);

		logger.console(`[docker] building image ${tag}`);

		if (!publicDir) throw new Error("publicDir is required");

		logger.console(
			`[docker] building image at ${capsule.path} with public dir ${publicDir}`,
		);

		if (this.options.copyNodeModules || template?.copyNodeModules) {
			// Copy node_modules to the public dir
			await this.copyDirectory(
				join(capsule.path, "..", "node_modules"),
				join(capsule.path, publicDir, "node_modules"),
			);
		}

		logger.console(`[docker] building image ${tag}`);

		if (template) {
			logger.console("[docker] using custom Dockerfile template");
			const relativePublicDir = path.isAbsolute(publicDir)
				? path.relative(capsule.path, publicDir)
				: publicDir;

			const dockerfile = await template.generate({
				capsulePath: capsule.path,
				publicDir: relativePublicDir,
				appName: appComponent.id.name,
				entryFile: this.options.entryFile,
			});

			capsule.fs.writeFileSync("Dockerfile", dockerfile);
		}

		const buildStream = await docker.buildImage(
			{
				context: capsule.path,
				src: ["."],
			},
			{
				dockerfile: template
					? "Dockerfile"
					: (this.options.dockerfileTemplate as string),
				t: tag,
				...buildOptions,
			},
		);

		buildStream.on("data", (data) => {
			try {
				const output = JSON.parse(data.toString());
				if (output.stream) {
					const cleanOutput = output.stream.trim();
					if (cleanOutput) {
						logger.console(cleanOutput);
					}
				}
			} catch (err) {
				logger.error("Error parsing docker build output:", err.toString());
			}
		});

		buildStream.on("error", (err) => {
			logger.error(err.toString());
		});

		await new Promise((resolve, reject) => {
			docker.modem.followProgress(buildStream, (err, res) => {
				if (err) {
					reject(err);
				}

				resolve(res);
			});
		});

		logger.console(`[docker] pushing image ${tag}`);

		const pushStream = await docker.getImage(tag).push({
			...pushOptions,
		});

		pushStream.on("data", (data) => {
			try {
				const output = JSON.parse(data.toString());
				if (output.status) {
					logger.console(`${output.status}: ${output.progress || ""}`);
				} else if (output.error) {
					logger.error(output.error);
				}
			} catch (err) {
				logger.error("Error parsing docker push output:", err.toString());
			}
		});

		pushStream.on("error", (err) => {
			logger.error(err.toString());
		});

		await new Promise((resolve, reject) => {
			docker.modem.followProgress(pushStream, (err, res) => {
				if (err) {
					reject(err);
				}

				resolve(res);
			});
		});

		logger.console(`[docker] image ${tag} pushed`);
	}

	private getTag(appComponent: Component, pipeName: PipeName) {
		const { org, tag, latest, version } = this.options;
		const appName = appComponent.id.name;
		const appOrg = appComponent.id.scope;
		const appVersion =
			version ??
			(pipeName === "snap"
				? appComponent.id.version.slice(0, 7)
				: appComponent.id.version);

		if (tag) return tag;

		if (latest) {
			return `${org ?? appOrg}/${appName}:latest`;
		}

		if (org) {
			return `${org}/${appName}:${appVersion}`;
		}

		return `${appOrg}/${appName}:${appVersion}`;
	}

	/**
	 * Recursively copy a directory but change the symlinks to be relative to the new destination
	 * @param src
	 * @param dest
	 */
	private async copyDirectory(src: string, dest: string): Promise<void> {
		try {
			await mkdir(dest, { recursive: true });
			const entries = await readdir(src, { withFileTypes: true });

			for (const entry of entries) {
				const srcPath = path.join(src, entry.name);
				const destPath = path.join(dest, entry.name);

				if (entry.isSymbolicLink()) {
					const link = await readlink(srcPath);
					const resolvedLink = path.resolve(path.dirname(srcPath), link);
					// Calculate the relative path from the original source directory to the resolved link
					const originalRelativeLink = path.relative(src, resolvedLink);
					// Now resolve this relative path against the new destination directory
					const newTarget = path.resolve(dest, originalRelativeLink);

					const relativeLink = path.relative(path.dirname(destPath), newTarget);
					await symlink(relativeLink, destPath);
				} else if (entry.isDirectory()) {
					await this.copyDirectory(srcPath, destPath);
				} else {
					await copyFile(srcPath, destPath);
				}
			}
		} catch (error) {
			console.error("Error copying directory:", error);
		}
	}

	private get docker() {
		return new Docker();
	}
}
