import { dedent } from "ts-dedent";
import { writeFileSync } from "node:fs";
import { join } from "node:path";

export interface DockerFileTemplate {
	name: string;
	copyNodeModules: boolean;
	generate(opts: GenerateOpts): Promise<string> | string;
}

type GenerateOpts = {
	capsulePath: string;
	publicDir: string;
	appName: string;
	entryFile: string;
};

export class NodeDockerFile implements DockerFileTemplate {
	name = "node";

	copyNodeModules = false;

	async generate(opts: GenerateOpts): Promise<string> {
		const { capsulePath, publicDir } = opts;

		const fullPublicDir = join(capsulePath, publicDir);

		const entryFile = join(fullPublicDir, opts.entryFile);

		const entryFileFn = await this.getEntryFileFn(entryFile);

		const formattedCommand = this.getFormattedCommand(
			opts.entryFile,
			entryFileFn,
		);

		// Save the command in a bash file so we can run it in the docker container
		writeFileSync(join(fullPublicDir, "start.sh"), formattedCommand);

		return dedent`FROM node:20-alpine

        WORKDIR /app
        
        COPY ./${opts.publicDir} .
        
        EXPOSE 8080

        ENV PORT=8080
		ENV IS_DOCKER="true"
        
        CMD ["sh", "start.sh"]`;
	}

	/**
	 * This function gets the function that initializes the entry file.
	 * If the entry file exposes a default function, it will be used.
	 * If it exposes a named function, it will be used.
	 * If it does not expose anything, we will just require the file.
	 * The function will use ESM as it supports both ESM and CJS.
	 *
	 * @param entryFile The path to the entry file.
	 * @returns A promise that resolves to either "default", a named function descriptor, or "require".
	 */
	private async getEntryFileFn(entryFile: string): Promise<
		| {
				type: "named" | "named-cjs";
				name: string;
		  }
		| "default"
		| "require"
		| "default-cjs"
	> {
		try {
			const file = this.getEntryFile(entryFile);
			const fileExtension = file.split(".").pop();
			const entryFileModule = await import(file).catch(
				// If the import fails, we will use the auto-requiring method
				() => ({}),
			);
			if (fileExtension === "cjs") {
				// When importing CJS files, the exports (default and named) are stored in the `default` property
				if (entryFileModule.default) {
					if (entryFileModule.default.default) {
						return "default-cjs";
					}

					if (entryFileModule.default.init) {
						return { type: "named-cjs", name: "init" };
					}

					if (entryFileModule.default.main) {
						return { type: "named-cjs", name: "main" };
					}

					if (entryFileModule.default.start) {
						return { type: "named-cjs", name: "start" };
					}

					if (entryFileModule.default.run) {
						return { type: "named-cjs", name: "run" };
					}
					return "default";
				}
			}

			if (entryFileModule.default) {
				if (entryFileModule.default.default) {
					return "default-cjs";
				}
				return "default";
			}
			if (entryFileModule.init) {
				return { type: "named", name: "init" };
			}
			if (entryFileModule.main) {
				return { type: "named", name: "main" };
			}
			if (entryFileModule.start) {
				return { type: "named", name: "start" };
			}
			if (entryFileModule.run) {
				return { type: "named", name: "run" };
			}
			return "require";
		} catch (e) {
			return "require";
		}
	}

	private getFormattedCommand(
		entryFile: string,
		type:
			| "default"
			| "default-cjs"
			| "require"
			| { type: "named" | "named-cjs"; name: string },
	): string {
		if (type === "default") {
			return `node -e "import('./${entryFile}').then((m) => m.default())"`;
		}

		if (type === "default-cjs") {
			return `node -e "require('./${entryFile}').default()"`;
		}

		if (type === "require") {
			return `node ./${entryFile}`;
		}

		if (type.type === "named") {
			return `node -e "import('./${entryFile}').then((m) => m.${type.name}())"`;
		}

		if (type.type === "named-cjs") {
			return `node -e "require('./${entryFile}').${type.name}()"`;
		}
	}

	private getEntryFile(entryFile: string): string {
		let result = entryFile;

		// If it's windows we need to replace the backslashes with forward slashes
		if (process.platform === "win32") {
			result = `file:///${result.replace(/\\/g, "/")}`;
		}

		return result;
	}
}

export class HtmlDockerFile implements DockerFileTemplate {
	name = "html";

	copyNodeModules = false;

	generate(opts: GenerateOpts): string {
		// Copy the public directory to the nginx html directory and serve it
		return dedent`FROM nginx:alpine

        EXPOSE 8080

        COPY ${opts.publicDir} /usr/share/nginx/html`;
	}
}
