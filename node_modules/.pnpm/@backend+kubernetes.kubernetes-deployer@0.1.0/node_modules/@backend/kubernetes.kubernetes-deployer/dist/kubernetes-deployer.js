import { Logger } from "@teambit/logger";
import k8s from "@kubernetes/client-node";
import { readFileSync } from "node:fs";
import { glob } from "glob";
import { DefaultGenerator } from "./generator.js";
export class KubernetesDeployer {
    constructor(options) {
        this.options = options;
    }
    static deploy(options) {
        const deployer = new KubernetesDeployer(options);
        return async (context) => {
            return deployer.deploy(context);
        };
    }
    async deploy(context) {
        const logger = new Logger(`${context.appComponent.displayName}:k8s-deploy`);
        const credentials = await this.options.adapter.getCredentials();
        logger.console("Connecting to Kubernetes cluster...");
        const kc = new k8s.KubeConfig();
        kc.loadFromClusterAndUser({
            server: credentials.endpoint,
            caData: credentials.certificate,
            name: "bitdeployer",
        }, {
            name: "bitdeployer",
            token: credentials.token,
        });
        const client = kc.makeApiClient(k8s.KubernetesObjectApi);
        const specs = [];
        // If no files are specified, generate the objects from the services
        if (this.options.files && this.options.files.length > 0) {
            for (const filePattern of this.options.files) {
                if (typeof filePattern === "string") {
                    const files = glob.sync(filePattern, {
                        cwd: context.capsule.path,
                        absolute: true,
                    });
                    for (const file of files) {
                        // Check if the file contains multiple resources '---', if so, split them and add them separately.
                        const content = readFileSync(file, "utf8");
                        const lines = content.split("---");
                        for (const line of lines) {
                            if (line.trim().length > 0) {
                                specs.push(k8s.loadYaml(line));
                            }
                        }
                    }
                }
                else {
                    // The Object generator may contain multiple specs too
                    const content = filePattern.generate();
                    for (const spec of content) {
                        specs.push(spec);
                    }
                }
            }
        }
        else {
            const { pipeName } = context;
            // Generate the objects from the services
            const platformServices = context.platformServices;
            const mainFrontend = context.mainFrontend;
            const mainBackend = context.mainBackend;
            // const servicesSpecs = platformServices.map((service) => {
            // 	const component = service.component;
            // 	const version =
            // 		pipeName === "snap"
            // 			? service.component.id.version.slice(0, 7)
            // 			: service.component.id.version;
            // 	const generator = new DefaultGenerator({
            // 		name: service.name,
            // 		image: `${this.options.organization ?? component.id.scope}/${
            // 			service.name
            // 		}:${version}`,
            // 	});
            // 	return generator.generate();
            // });
            // const mainFrontendVersion =
            // 	pipeName === "snap"
            // 		? mainFrontend.component.id.version.slice(0, 7)
            // 		: mainFrontend.component.id.version;
            // const mainFrontendGenerator = new DefaultGenerator({
            // 	name: mainFrontend.name,
            // 	expose: true,
            // 	image: `${
            // 		this.options.organization ?? mainFrontend.component.id.scope
            // 	}/${mainFrontend.name}:${mainFrontendVersion}`,
            // });
            // const mainFrontendSpecs = mainFrontendGenerator.generate();
            // const mainBackendVersion =
            // 	pipeName === "snap"
            // 		? mainBackend.component.id.version.slice(0, 7)
            // 		: mainBackend.component.id.version;
            // const mainBackendGenerator = new DefaultGenerator({
            // 	name: mainBackend.name,
            // 	expose: true,
            // 	image: `${
            // 		this.options.organization ?? mainBackend.component.id.scope
            // 	}/${mainBackend.name}:${mainBackendVersion}`,
            // });
            // const mainBackendSpecs = mainBackendGenerator.generate();
            // specs.push(...mainFrontendSpecs, ...mainBackendSpecs);
            // for (const serviceSpecs of servicesSpecs) {
            // 	specs.push(...serviceSpecs);
            // }
            const servicesSpecs = platformServices.map((service) => this.getGenerator(service, pipeName).generate());
            const mainFrontendSpecs = this.getGenerator(mainFrontend, pipeName, true).generate();
            const mainBackendSpecs = this.getGenerator(mainBackend, pipeName, true).generate();
            specs.push(...mainFrontendSpecs, ...mainBackendSpecs);
            for (const serviceSpecs of servicesSpecs) {
                specs.push(...serviceSpecs);
            }
        }
        if (specs.length === 0) {
            throw new Error("No files to deploy");
        }
        // Create the env variables to attach to the deployments
        const services = context.platformServices;
        const env = services
            .map((service) => ({
            name: `REMOTE_URL_${service.name.toUpperCase().replaceAll("-", "_")}`,
            value: service.url || null,
        }))
            .concat([
            {
                name: "BACKEND_URL",
                value: context.mainBackend.url,
            },
        ]);
        const envServices = env
            .map((e) => {
            // Ignore the BACKEND_URL
            if (e.name === "BACKEND_URL")
                return null;
            return {
                appName: e.name
                    .replace("REMOTE_URL_", "")
                    .toLowerCase()
                    .replaceAll("_", "-"),
                url: e.value,
            };
        })
            .filter((e) => e !== null);
        env.push({
            name: "BIT_SERVICES",
            value: JSON.stringify(envServices),
        });
        logger.console("Applying Kubernetes specs...");
        for await (const spec of specs) {
            logger.console(`Applying ${spec.kind} ${spec.metadata.name}`);
            if (spec.kind === "Deployment") {
                await this.applyDeployment(client, spec, env);
                logger.console(`Applied ${spec.kind} ${spec.metadata.name}`);
                continue;
            }
            try {
                await client.create({
                    ...spec,
                    metadata: {
                        ...spec.metadata,
                        namespace: spec.metadata.namespace ?? this.options.namespace ?? "default",
                        annotations: {
                            ...spec.metadata.annotations,
                            "kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
                        },
                    },
                });
                logger.console(`Applied ${spec.kind} ${spec.metadata.name}`);
            }
            catch (e) {
                if (!e.body) {
                    console.error(`Failed to apply ${spec.kind} ${spec.metadata.name}`);
                    throw e;
                }
                if (e.body.reason !== "AlreadyExists") {
                    console.error(`Failed to apply ${spec.kind} ${spec.metadata.name}`, e.body);
                    throw e.body.message;
                }
                await client
                    .replace({
                    ...spec,
                    metadata: {
                        ...spec.metadata,
                        namespace: spec.metadata.namespace ?? this.options.namespace ?? "default",
                    },
                })
                    .catch((err) => {
                    console.error(`Failed to update ${spec.kind} ${spec.metadata.name}`, err.body);
                    throw err;
                });
                logger.console(`Updated ${spec.kind} ${spec.metadata.name}`);
            }
        }
        logger.console("Applied Kubernetes specs.");
    }
    async applyDeployment(client, spec, env) {
        const newSpec = {
            ...spec,
            spec: {
                ...spec.spec,
                template: {
                    ...spec.spec.template,
                    spec: {
                        ...spec.spec.template.spec,
                        containers: spec.spec.template.spec.containers.map((container) => ({
                            ...container,
                            env: [...(container.env ?? []), ...env],
                        })),
                    },
                },
            },
        };
        try {
            await client.create({
                ...newSpec,
                metadata: {
                    ...newSpec.metadata,
                    namespace: newSpec.metadata.namespace ?? this.options.namespace,
                    annotations: {
                        ...newSpec.metadata.annotations,
                        "kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
                    },
                },
            });
        }
        catch (e) {
            if (e.body.reason !== "AlreadyExists") {
                throw e;
            }
            await client.replace({
                ...newSpec,
                metadata: {
                    ...newSpec.metadata,
                    namespace: newSpec.metadata.namespace ?? this.options.namespace,
                    annotations: {
                        ...newSpec.metadata.annotations,
                        "kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
                    },
                },
            });
        }
    }
    getGenerator(service, pipeName, expose = false) {
        const component = service.component;
        const version = pipeName === "snap"
            ? service.component.id.version.slice(0, 7)
            : service.component.id.version;
        return new DefaultGenerator({
            name: service.name,
            image: `${this.options.organization ?? component.id.scope}/${service.name}:${version}`,
            expose,
        });
    }
}
//# sourceMappingURL=kubernetes-deployer.js.map