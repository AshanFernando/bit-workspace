import type {
	PlatformBuildContext,
	PlatformServiceBuild,
} from "@bitdev/platforms.platform";
import { Logger } from "@teambit/logger";
import type { PipeName } from "@teambit/builder";
import k8s from "@kubernetes/client-node";
import { readFileSync } from "node:fs";
import { glob } from "glob";
import type { K8Adapter } from "./adapters.js";
import { DefaultGenerator, type K8ObjectGenerator } from "./generator.js";

export type K8sTaskOptions = {
	/**
	 * The adapter to use to connect to the Kubernetes cluster. (e.g. GKE, EKS, AKS, etc.)
	 */
	adapter: K8Adapter;
	/**
	 * The files to apply to the Kubernetes cluster.
	 * It can be a local file path or a URL. If it's a local file, it should be relative to the
	 * config file.
	 */
	files?: (K8ObjectGenerator | string)[];
	/**
	 * The namespace to deploy to. If not specified, it will use the default namespace.
	 */
	namespace?: string;
	/**
	 * Organization to use for all the Docker images.
	 * @default "Organization of the app component"
	 */
	organization?: string;
};

export class KubernetesDeployer {
	constructor(private options: K8sTaskOptions) {}

	static deploy(options: K8sTaskOptions) {
		const deployer = new KubernetesDeployer(options);
		return async (context: PlatformBuildContext) => {
			return deployer.deploy(context);
		};
	}

	private async deploy(context: PlatformBuildContext) {
		const logger = new Logger(`${context.appComponent.displayName}:k8s-deploy`);
		const credentials = await this.options.adapter.getCredentials();

		logger.console("Connecting to Kubernetes cluster...");

		const kc = new k8s.KubeConfig();
		kc.loadFromClusterAndUser(
			{
				server: credentials.endpoint,
				caData: credentials.certificate,
				name: "bitdeployer",
			},
			{
				name: "bitdeployer",
				token: credentials.token,
			},
		);

		const client = kc.makeApiClient(k8s.KubernetesObjectApi);

		const specs: k8s.KubernetesObject[] = [];

		// If no files are specified, generate the objects from the services
		if (this.options.files && this.options.files.length > 0) {
			for (const filePattern of this.options.files) {
				if (typeof filePattern === "string") {
					const files = glob.sync(filePattern, {
						cwd: context.capsule.path,
						absolute: true,
					});
					for (const file of files) {
						// Check if the file contains multiple resources '---', if so, split them and add them separately.
						const content = readFileSync(file, "utf8");
						const lines = content.split("---");
						for (const line of lines) {
							if (line.trim().length > 0) {
								specs.push(k8s.loadYaml(line));
							}
						}
					}
				} else {
					// The Object generator may contain multiple specs too
					const content = filePattern.generate();
					for (const spec of content) {
						specs.push(spec);
					}
				}
			}
		} else {
			const { pipeName } = context;
			// Generate the objects from the services
			const platformServices = context.platformServices;
			const mainFrontend = context.mainFrontend;
			const mainBackend = context.mainBackend;

			// const servicesSpecs = platformServices.map((service) => {
			// 	const component = service.component;
			// 	const version =
			// 		pipeName === "snap"
			// 			? service.component.id.version.slice(0, 7)
			// 			: service.component.id.version;

			// 	const generator = new DefaultGenerator({
			// 		name: service.name,
			// 		image: `${this.options.organization ?? component.id.scope}/${
			// 			service.name
			// 		}:${version}`,
			// 	});

			// 	return generator.generate();
			// });

			// const mainFrontendVersion =
			// 	pipeName === "snap"
			// 		? mainFrontend.component.id.version.slice(0, 7)
			// 		: mainFrontend.component.id.version;

			// const mainFrontendGenerator = new DefaultGenerator({
			// 	name: mainFrontend.name,
			// 	expose: true,
			// 	image: `${
			// 		this.options.organization ?? mainFrontend.component.id.scope
			// 	}/${mainFrontend.name}:${mainFrontendVersion}`,
			// });

			// const mainFrontendSpecs = mainFrontendGenerator.generate();

			// const mainBackendVersion =
			// 	pipeName === "snap"
			// 		? mainBackend.component.id.version.slice(0, 7)
			// 		: mainBackend.component.id.version;

			// const mainBackendGenerator = new DefaultGenerator({
			// 	name: mainBackend.name,
			// 	expose: true,
			// 	image: `${
			// 		this.options.organization ?? mainBackend.component.id.scope
			// 	}/${mainBackend.name}:${mainBackendVersion}`,
			// });

			// const mainBackendSpecs = mainBackendGenerator.generate();

			// specs.push(...mainFrontendSpecs, ...mainBackendSpecs);
			// for (const serviceSpecs of servicesSpecs) {
			// 	specs.push(...serviceSpecs);
			// }

			const servicesSpecs = platformServices.map((service) =>
				this.getGenerator(service, pipeName).generate(),
			);

			const mainFrontendSpecs = this.getGenerator(
				mainFrontend,
				pipeName,
				true,
			).generate();
			const mainBackendSpecs = this.getGenerator(
				mainBackend,
				pipeName,
				true,
			).generate();

			specs.push(...mainFrontendSpecs, ...mainBackendSpecs);
			for (const serviceSpecs of servicesSpecs) {
				specs.push(...serviceSpecs);
			}
		}

		if (specs.length === 0) {
			throw new Error("No files to deploy");
		}

		// Create the env variables to attach to the deployments
		const services = context.platformServices;

		const env: k8s.V1EnvVar[] = services
			.map((service) => ({
				name: `REMOTE_URL_${service.name.toUpperCase().replaceAll("-", "_")}`,
				value: service.url || null,
			}))
			.concat([
				{
					name: "BACKEND_URL",
					value: context.mainBackend.url,
				},
			]);

		const envServices = env
			.map((e) => {
				// Ignore the BACKEND_URL
				if (e.name === "BACKEND_URL") return null;
				return {
					appName: e.name
						.replace("REMOTE_URL_", "")
						.toLowerCase()
						.replaceAll("_", "-"),
					url: e.value,
				};
			})
			.filter((e) => e !== null);

		env.push({
			name: "BIT_SERVICES",
			value: JSON.stringify(envServices),
		});

		logger.console("Applying Kubernetes specs...");
		for await (const spec of specs) {
			logger.console(`Applying ${spec.kind} ${spec.metadata.name}`);

			if (spec.kind === "Deployment") {
				await this.applyDeployment(client, spec as k8s.V1Deployment, env);
				logger.console(`Applied ${spec.kind} ${spec.metadata.name}`);
				continue;
			}

			try {
				await client.create({
					...spec,
					metadata: {
						...spec.metadata,
						namespace:
							spec.metadata.namespace ?? this.options.namespace ?? "default",
						annotations: {
							...spec.metadata.annotations,
							"kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
						},
					},
				});
				logger.console(`Applied ${spec.kind} ${spec.metadata.name}`);
			} catch (e) {
				if (!e.body) {
					console.error(`Failed to apply ${spec.kind} ${spec.metadata.name}`);
					throw e;
				}

				if (e.body.reason !== "AlreadyExists") {
					console.error(
						`Failed to apply ${spec.kind} ${spec.metadata.name}`,
						e.body,
					);
					throw e.body.message;
				}
				await client
					.replace({
						...spec,
						metadata: {
							...spec.metadata,
							namespace:
								spec.metadata.namespace ?? this.options.namespace ?? "default",
						},
					})
					.catch((err) => {
						console.error(
							`Failed to update ${spec.kind} ${spec.metadata.name}`,
							err.body,
						);
						throw err;
					});
				logger.console(`Updated ${spec.kind} ${spec.metadata.name}`);
			}
		}

		logger.console("Applied Kubernetes specs.");
	}

	private async applyDeployment(
		client: k8s.KubernetesObjectApi,
		spec: k8s.V1Deployment,
		env: k8s.V1EnvVar[],
	) {
		const newSpec: k8s.V1Deployment = {
			...spec,
			spec: {
				...spec.spec,
				template: {
					...spec.spec.template,
					spec: {
						...spec.spec.template.spec,
						containers: spec.spec.template.spec.containers.map((container) => ({
							...container,
							env: [...(container.env ?? []), ...env],
						})),
					},
				},
			},
		};

		try {
			await client.create({
				...newSpec,
				metadata: {
					...newSpec.metadata,
					namespace: newSpec.metadata.namespace ?? this.options.namespace,
					annotations: {
						...newSpec.metadata.annotations,
						"kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
					},
				},
			});
		} catch (e) {
			if (e.body.reason !== "AlreadyExists") {
				throw e;
			}
			await client.replace({
				...newSpec,
				metadata: {
					...newSpec.metadata,
					namespace: newSpec.metadata.namespace ?? this.options.namespace,
					annotations: {
						...newSpec.metadata.annotations,
						"kubectl.kubernetes.io/restartedAt": new Date().toISOString(),
					},
				},
			});
		}
	}

	private getGenerator(
		service: PlatformServiceBuild,
		pipeName: PipeName,
		expose = false,
	): K8ObjectGenerator {
		const component = service.component;
		const version =
			pipeName === "snap"
				? service.component.id.version.slice(0, 7)
				: service.component.id.version;

		return new DefaultGenerator({
			name: service.name,
			image: `${this.options.organization ?? component.id.scope}/${
				service.name
			}:${version}`,
			expose,
		});
	}
}
