import { merge } from 'lodash';
import { SpacingWeight } from './spacing-weight.js';

export type SpacingSegment = {
  /**
   * amounts of units in the segment. 
   */
  levels?: number;

  /**
   * multiplier for each.
   */
  multiplier?: number;
};

export type SpacingSegmentOptions = {
  /**
   * subunits below the base unit number.  
   */
  small?: SpacingSegment;

  /**
   * subunits above base unit number.
   */
  medium?: SpacingSegment;

  /**
   * subunits for after levels of medium are concluded.
   */
  large?: SpacingSegment;

  /**
   * additional spacing segments.
   */
  [key: string]: SpacingSegment;
};

/**
 * spacing options.
 */
export type SpacingOptions = {
  /**
   * base unit in pixels.
   */
  baseUnit?: number;

  /**
   * definition of the spacing segments 
   * generated for spacing.
   */
  segments?: SpacingSegmentOptions;
};


export const defaultSpacingOptions: SpacingOptions = {
  baseUnit: 8,
  segments: {
    small: {
      levels: 5,
      multiplier: 0.25
    },
    medium: {
      levels: 4,
      multiplier: 0.5
    },
    large: {
      levels: 4,
      multiplier: 1
    }
  }
}

/**
 * Spacing values help to create consistent interfaces 
 * by clearly defining relationships between components.
 */
export class Spacing {
  constructor(
    private options: SpacingOptions,
    readonly weights: SpacingWeight[]
  ) {}

  /**
   * retrieve levels by a segment.
   */
  segment(name: string) {
    const segmentOptions = this.options.segments[name];
    if (!segmentOptions) return undefined;

    return this.weights.filter((weight) => {
      return weight.segment === name;
    });
  }

  /**
   * half the size.
   */
  get half() {
    return this.get(50);
  }

  // get medium() {
  //   return this.get(250);
  // }

  /**
   * default spacing.
   * uses the base unit level.
   */
  get default() {
    return this.get(100);
  }

  /**
   * get double 
   */
  get double() {
    return this.get(200);
  }

  /**
   * get triple. the base unit size.
   */
  get triple() {
    return this.get(300);
  }

  get(weight: number) {
    return this.weights.find((spaceWeight) => {
      return spaceWeight.weight === weight;
    });
  }

  generateTokens() {
    return this.weights.reduce<Record<string, string>>((acc, weight) => {
      acc[weight.token] = `${weight.pixels}px`;
      return acc;
    }, {});
  }

  /**
   * level 
   */
  level(name: number) {
    return this.weights.find((spaceWeight) => {
      return spaceWeight.level === name;
    });
  }

  toObject() {
    return {
      options: this.options,
      weights: this.weights.map((weight) => weight.toObject())
    }
  }

  createTokens() {
    return this.weights.reduce((acc, weight) => {
      return { ...acc, ...weight.toToken() };
    }, {});
  }

  /**
   * create spacing values based on options.
   */
  static create(userSpacingOptions: SpacingOptions = {}) {
    const options = merge(defaultSpacingOptions, userSpacingOptions);
    const segments = Object.values(options.segments)
    const levels = segments.reduce((acc, segment) => {
      return acc + segment.levels || 0;
    }, 0);

    const spacingArray = new Array(levels).fill(undefined);
    let totalLevels = 0;
    let totalFactors = 0;

    const segmentIndex = Object.keys(options.segments).map((segmentKey) => {
      const segValue: SpacingSegment = options.segments[segmentKey];
      const levelsBefore = totalLevels;
      totalLevels += segValue.levels;
      const endFactor = levelsBefore ? 
        (segValue.levels * segValue.multiplier) + totalFactors
        : (segValue.levels * segValue.multiplier) + totalFactors - segValue.multiplier;
      totalFactors += endFactor;

      return {
        name: segmentKey,
        firstLevel: levelsBefore,
        initialKey: segValue.levels + levelsBefore,
        endFactor,
        ...segValue
      }
    });

    let multiplier = 0;
    const weights: SpacingWeight[] = spacingArray.map((_, level) => {
      const segment = segmentIndex.find((seg) => {
        if (seg.initialKey > level) return true;
        return false;
      });

      if (level !== 0) multiplier += segment.multiplier; 

      return SpacingWeight.create({
        segment: segment.name,
        level,
        multiplier,
        baseUnit: options.baseUnit,
      })
    });

    return new Spacing(options, weights);
  }
}
