import { Graph } from 'cleargraph';
import { fromExtension, fromExtensions } from './from-extension.js';
function getName(manifest) {
    return manifest.id || manifest.name;
}
export default class DependencyGraph extends Graph {
    constructor() {
        super(...arguments);
        this.cache = new Map();
    }
    getRuntimeDependencies(aspect, runtime, options = {}) {
        const dependencies = this.successors(aspect.name);
        const runtimeDeps = this.successors(aspect.name, (edge) => {
            if (!edge.runtime)
                return false;
            return edge.runtime === runtime.name;
        });
        const runtimeManifest = aspect.getRuntime(runtime);
        if (!runtimeManifest)
            return Array.from(dependencies.values());
        if (runtimeDeps && runtimeDeps.size)
            return this.sortDeps(runtimeManifest.dependencies, Array.from(runtimeDeps.values()), options);
        return this.sortDeps(runtimeManifest.dependencies, Array.from(dependencies.values()), options);
    }
    sortDeps(originalDependencies, targetDependencies, options = {}) {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const _originalDependencies = options.getName ? originalDependencies?.map((aspect) => {
            if (!options.getName)
                return aspect;
            // eslint-disable-next-line no-param-reassign
            aspect.id = options.getName(aspect);
            return aspect;
        }) || [] : originalDependencies;
        return targetDependencies.sort((a, b) => {
            return _originalDependencies.findIndex(item => item.id === a.id) - _originalDependencies.findIndex(item => item.id === b.id);
        });
    }
    byExecutionOrder() {
        return this.toposort(true);
    }
    async enrichRuntimeExtension(id, aspect, runtime, runtimes, requireFn, options = {}) {
        await requireFn(aspect, runtime);
        const runtimeManifest = aspect.getRuntime(runtime);
        if (!runtimeManifest)
            return;
        const deps = runtimeManifest.dependencies;
        if (!deps)
            return;
        // eslint-disable-next-line consistent-return
        const promises = deps.map(async (dep) => {
            const depId = options.getName ? options.getName(dep) : dep.id;
            if (!this.hasNode(depId)) {
                this.add(dep);
                if (dep.declareRuntime) {
                    runtimes.add(dep.declareRuntime);
                }
                const node = this.get(depId);
                if (!node)
                    return undefined;
                await requireFn(node, runtime);
                await this.enrichRuntimeExtension(depId, this.get(depId), runtime, runtimes, requireFn);
            }
            this.setEdge(id, depId, {
                runtime: runtime.name,
                type: 'runtime-dependency'
            });
        });
        // eslint-disable-next-line consistent-return
        return Promise.all(promises);
    }
    async enrichRuntime(runtime, runtimes, requireFn, options = {}) {
        const promises = Array.from(this.nodes.entries()).map(async ([id, aspect]) => {
            return this.enrichRuntimeExtension(id, aspect, runtime, runtimes, requireFn, options);
        });
        return Promise.all(promises);
    }
    add(manifest) {
        const { vertices, edges } = fromExtension(manifest);
        this.setNodes(vertices);
        this.setEdges(edges);
        return this;
    }
    load(extensions) {
        const newExtensions = extensions.filter((extension) => {
            if (!extension.id)
                return false;
            return !this.get(extension.id);
        });
        const { vertices, edges } = fromExtensions(newExtensions);
        // Only set new vertices
        this.setNodes(vertices, false); // false because we don't want to override already-loaded extensions
        this.setEdges(edges);
        return this;
    }
    // :TODO refactor this asap
    getExtension(manifest) {
        const id = getName(manifest);
        const cachedVertex = this.cache.get(id);
        if (cachedVertex)
            return cachedVertex;
        const res = this.node(id);
        if (res) {
            this.cache.set(res.name, res);
            return res;
        }
        return null;
    }
    get extensions() {
        return Array.from(this.nodes.values());
    }
    get aspects() {
        return this.extensions;
    }
    get(id) {
        const cachedVertex = this.cache.get(id);
        if (cachedVertex)
            return cachedVertex;
        const res = this.node(id);
        if (res) {
            this.cache.set(res.name, res);
            return res;
        }
        return null;
    }
    /**
     * build Harmony from a single extension.
     */
    static fromRoot(extension) {
        const { vertices, edges } = fromExtension(extension);
        return new DependencyGraph(vertices, edges);
    }
    /**
     * build Harmony from set of extensions
     */
    static from(extensions, options = {}) {
        const { vertices, edges } = fromExtensions(extensions, options);
        return new DependencyGraph(vertices, edges);
    }
}
//# sourceMappingURL=extension-graph.js.map