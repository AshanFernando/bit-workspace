import { ExtensionInstantiationException } from '../exceptions/extension-init-error.js';
/**
 * harmony's extension definition. this can be used to define and extend `Harmony` applications.
 */
export class Extension {
    constructor(
    /**
     * manifest of the extension.
     */
    manifest) {
        this.manifest = manifest;
        this._instance = null;
        this._loaded = false;
    }
    /**
     * returns the instance of the extension
     */
    get instance() {
        return this._instance;
    }
    get name() {
        return this.manifest.id || this.manifest.name;
    }
    get id() {
        return this.name;
    }
    get dependencies() {
        return this.manifest.dependencies || [];
    }
    get provider() {
        return this.manifest.provider;
    }
    get files() {
        return this.manifest.files;
    }
    /**
     * returns an indication of the extension already loaded (the provider run)
     * We don't rely on the instance since an extension provider might return null
     */
    get loaded() {
        return this._loaded;
    }
    toString() {
        return JSON.stringify(this.name);
    }
    buildSlotRegistries(slots, context) {
        return slots.map((slot) => {
            return slot(() => {
                return context.current;
            });
        });
    }
    get declareRuntime() {
        return this.manifest.declareRuntime;
    }
    getRuntime(runtime) {
        return this.manifest.getRuntime(runtime);
    }
    getRuntimes() {
        return this.manifest.getRuntimes();
    }
    getSlots(extensionRuntime) {
        if (extensionRuntime.slots && extensionRuntime.slots.length) {
            return extensionRuntime.slots;
        }
        return this.manifest.slots || [];
    }
    getConfig(context, extensionRuntime) {
        const defaultConfig = extensionRuntime.defaultConfig || this.manifest.defaultConfig || {};
        const config = context.config.get(this.name) || {};
        // eslint-disable-next-line prefer-object-spread
        return Object.assign({}, defaultConfig, config);
    }
    /**
     * initiate Harmony in run-time.
     */
    async __run(dependencies, context, runtime) {
        // eslint-disable-next-line prefer-destructuring
        const name = this.name;
        context.initExtension(name);
        const extensionRuntime = this.getRuntime(runtime);
        if (!extensionRuntime) {
            return undefined;
        }
        // @ts-ignore
        const registries = this.buildSlotRegistries(this.getSlots(extensionRuntime), context);
        const config = this.getConfig(context, extensionRuntime);
        if (!this.loaded) {
            if (extensionRuntime.provider)
                this._instance = await extensionRuntime.provider(dependencies, config, registries, context);
            else {
                try {
                    // @ts-ignore
                    // eslint-disable-next-line new-cap
                    this._instance = new extensionRuntime.manifest(...dependencies);
                }
                catch (err) {
                    throw new ExtensionInstantiationException(err.toString());
                }
            }
            ;
            // @ts-ignore adding the extension ID to the instance.
            // this._instance.id = this.manifest.name;
            // @ts-ignore adding the extension ID to the instance.
            // this._instance.config = config;
            this._loaded = true;
            return this._instance;
        }
        context.endExtension();
        return Promise.resolve(this.instance);
    }
}
//# sourceMappingURL=extension.js.map