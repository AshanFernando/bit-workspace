// import 'reflect-metadata';
import ExtensionGraph from './extension-graph/extension-graph.js';
import ExtensionLoadError from './exceptions/extension-load-error.js';
import { asyncForEach } from './utils/index.js';
import { Config } from './config/config.js';
import { Runtimes } from './runtimes/runtimes.js';
import { RuntimeNotDefined } from './runtimes/exceptions/index.js';
export class Harmony {
    constructor(
    /**
     * extension graph
     */
    graph, 
    /**
     * harmony top level config
     */
    config, runtimes, activeRuntime, depOptions) {
        this.graph = graph;
        this.config = config;
        this.runtimes = runtimes;
        this.activeRuntime = activeRuntime;
        this.depOptions = depOptions;
        this.current = null;
    }
    /**
     * list all registered extensions
     */
    get extensions() {
        return this.graph.nodes;
    }
    /**
     * list all registered extensions ids
     */
    get extensionsIds() {
        return [...this.graph.nodes.keys()];
    }
    /**
     * load an Aspect into the dependency graph.
     */
    async load(extensions) {
        return this.set(extensions);
    }
    /**
     * set extensions during Harmony runtime.
     * hack!
     */
    async set(extensions) {
        this.graph.load(extensions);
        // Only load new extensions and their dependencies
        const extensionsToLoad = extensions.map((ext) => {
            // @ts-ignore
            return Reflect.getMetadata('harmony:name', ext) || ext.id || ext.name;
        });
        // @ts-ignore
        await this.graph.enrichRuntime(this.runtime, this.runtimes, () => { });
        // @ts-ignore
        const subgraphs = this.graph.successorsSubgraph(extensionsToLoad);
        if (subgraphs) {
            const executionOrder = subgraphs.toposort(true);
            await asyncForEach(executionOrder, async (ext) => {
                if (!this.runtime)
                    throw new RuntimeNotDefined(this.activeRuntime);
                await this.runOne(ext, this.runtime);
            });
        }
    }
    async runOne(extension, runtime) {
        if (extension.loaded)
            return;
        // create an index of all vertices in dependency graph
        const deps = this.graph.getRuntimeDependencies(extension, runtime, this.depOptions);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const instances = deps.map(extension => extension.instance);
        try {
            // eslint-disable-next-line consistent-return
            return extension.__run(instances, this, runtime);
        }
        catch (err) {
            throw new ExtensionLoadError(extension, err);
        }
    }
    getDependencies(aspect) {
        if (!this.runtime)
            throw new RuntimeNotDefined(this.activeRuntime);
        return this.graph.getRuntimeDependencies(aspect, this.runtime, this.depOptions);
    }
    initExtension(id) {
        this.current = id;
    }
    endExtension() {
        this.current = null;
    }
    /**
     * get an extension from harmony.
     */
    get(id) {
        const extension = this.graph.get(id);
        if (!extension || !extension.instance)
            throw new Error(`failed loading extension ${id}`);
        return extension.instance;
    }
    resolveRuntime(name) {
        return this.runtimes.get(name);
    }
    /**
     * run all aspects and resolve dependency instances.
     */
    async run(requireFn) {
        const runtime = this.resolveRuntime(this.activeRuntime);
        this.runtime = runtime;
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const defaultRequireFn = async (aspect, runtime) => {
            const runtimeFile = runtime.getRuntimeFile(aspect.files);
            // eslint-disable-next-line no-useless-return
            if (!runtimeFile)
                return;
            // runtime.require(runtimeFile);
        };
        // requireFn ? await requireFn(aspect, runtime) : defaultRequireFn(this.graph);
        await this.graph.enrichRuntime(runtime, this.runtimes, requireFn || defaultRequireFn, this.depOptions);
        const executionOrder = this.graph.byExecutionOrder();
        await asyncForEach(executionOrder, async (ext) => {
            await this.runOne(ext, runtime);
        });
    }
    /**
     * load and run an Harmony app.
     */
    static async run(aspects, runtime, globalConfig = {}, options = {}) {
        const harmony = await Harmony.load(aspects, runtime, globalConfig, options);
        await harmony.run();
        return harmony;
    }
    /**
     * Load an Harmony app, do not create instances
     * in the container yet.
     */
    static async load(aspects, runtime, globalConfig = {}, options = {}) {
        const aspectGraph = ExtensionGraph.from(aspects, options);
        const runtimes = await Runtimes.load(aspectGraph);
        return new Harmony(aspectGraph, Config.from(globalConfig), runtimes, runtime, options);
    }
}
//# sourceMappingURL=harmony.js.map