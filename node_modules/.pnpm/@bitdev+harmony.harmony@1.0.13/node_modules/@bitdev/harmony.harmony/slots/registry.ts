import { flatten } from "lodash-es";
import { SortOptions } from "./slot-registry-options.js";

export class SlotRegistry<T> {
  constructor(
    private registerFn: () => string,

    /**
     * map of aspects associated with their 
     * corresponding values.
     */
    readonly map = new Map<string, T>()
  ) {}

  /**
   * get a slot value by extension id.
   */
  get(id: string): T|undefined {
    return this.map.get(id);
  }

  /**
   * the the length of the slot.
   * computes 
   */
  get length() {
    const values = this.flatValues();
    if (!Array.isArray(values)) return this.map.size;
    return values.length;
  }

  /**
   * get a flat list of all values.
   */
  flatValues(): T {
    return flatten(this.values());
  }

  /**
   * get a slot value by its 'name' property.
   * search for other values using the `key` argument.
   */
  getByName(name: string, key: string = 'name'): T|undefined {
    const values = this.flatValues();
    if (!Array.isArray(values)) return undefined;
    return values.find((value) => {
      return value[key] === name;
    });
  }

  /**
   * sort slot values by a `weight` property.
   * use different keys.
   */
  sortByWeight({
    key = 'weight',
    direction = 'asc',
    values: targetValues
  }: SortOptions<T> = {}): T[] {
    const values = targetValues || this.flatValues();
    if (!Array.isArray(values)) return undefined;
    return values.sort((valueA, valueB) => {
      const weightA = valueA[key] || 0;
      const weightB = valueB[key] || 0;

      if (direction === 'desc') return weightB - weightA;
      return weightA - weightB;
    });
  }

  /**
   * return an array of all slots.
   */
  toArray() {
    return Array.from(this.map.entries());
  }

  /**
   * get all registered values.
   */
  values() {
    return Array.from(this.map.values());
  }

  /**
   * register a new entry to the slot registry
   */
  register(value: T) {
    const id = this.registerFn();
    this.map.set(id, value);
  }
}
