import { execFile } from 'node:child_process';
import { build } from 'esbuild';
import { CAPSULE_ARTIFACTS_DIR } from '@teambit/builder';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
export class NodeApp {
    constructor(name, mainFile, customBuild, deploy, nodeBin = 'node', artifactName = 'app-bundle', bundleFileName = `${name}.cjs`, esbuildOptions = {}, showNameInOutputs = true) {
        this.name = name;
        this.mainFile = mainFile;
        this.customBuild = customBuild;
        this.deploy = deploy;
        this.nodeBin = nodeBin;
        this.artifactName = artifactName;
        this.bundleFileName = bundleFileName;
        this.esbuildOptions = esbuildOptions;
        this.showNameInOutputs = showNameInOutputs;
        this.applicationType = 'node';
    }
    async getMainFile() {
        const url = fileURLToPath(await this.mainFile);
        return url;
    }
    async run(context) {
        const logger = context.createLogger(this.name);
        // const [from, to] = this.portRange;
        const port = context.port || 3000;
        const mainFile = await this.getMainFile();
        const contextVars = context.envVariables;
        const child = execFile(this.nodeBin, [mainFile], {
            cwd: context.hostRootDir,
            env: {
                ...process.env,
                ...contextVars,
                PORT: port.toString(),
            }
        }, (error) => {
            if (error) {
                // @todo: this is causing uncaughtException in the main process. a better way to handle this would be to use promise.
                // however, since it expects to return a number, it would require a bigger refactor.
                // eslint-disable-next-line @typescript-eslint/no-throw-literal
                throw error;
            }
        });
        child.stdout?.on('data', (data) => {
            if (!this.showNameInOutputs)
                return logger.console(`${data.toString()}`);
            logger.console(`[${this.name}]: ${data.toString()}`);
        });
        process.on('exit', () => {
            child.kill('SIGKILL');
        });
        return {
            appName: this.name,
            port
        };
    }
    get outputDir() {
        return join(CAPSULE_ARTIFACTS_DIR, this.artifactName);
    }
    async build(context) {
        if (this.customBuild)
            return this.customBuild(context);
        const rootDir = context.capsule.path;
        const outputDir = join(rootDir, this.outputDir);
        const mainFile = await this.getMainFile();
        const result = await build({
            ...this.esbuildOptions,
            entryPoints: [mainFile],
            bundle: true,
            platform: 'node',
            outfile: join(outputDir, this.bundleFileName),
        });
        return {
            errors: result.errors.map((error) => {
                return new Error(error.detail);
            }),
            artifacts: [
                {
                    name: this.artifactName,
                    globPatterns: [this.outputDir],
                },
            ],
            metadata: {
                publicDir: this.outputDir
            }
        };
    }
    static from(options) {
        return new NodeApp(options.name, options.mainPath, options.build, options.deploy);
    }
}
//# sourceMappingURL=node-app.js.map