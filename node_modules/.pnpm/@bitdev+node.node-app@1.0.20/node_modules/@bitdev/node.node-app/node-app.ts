import { execFile } from 'node:child_process';
import { build, BuildOptions } from 'esbuild';
import { CAPSULE_ARTIFACTS_DIR } from '@teambit/builder';
import type { Application, DeployFn, AppContext, ApplicationInstance, BuildFn, AppBuildResult, AppBuildContext } from '@teambit/application';
import { NodeAppOptions } from './node-app-options.js';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';

export class NodeApp implements Application {
  constructor(
    readonly name: string,
    readonly mainFile: Promise<string>|string,
    readonly customBuild?: BuildFn,
    readonly deploy?: DeployFn,
    readonly nodeBin: string = 'node',
    readonly artifactName: string = 'app-bundle',
    readonly bundleFileName: string = `${name}.cjs`,
    readonly esbuildOptions: BuildOptions = {},
    readonly showNameInOutputs = true
  ) {}

  applicationType = 'node';

  private async getMainFile() {
    const url = fileURLToPath(await this.mainFile);
    return url;
  }

  async run(context: AppContext): Promise<ApplicationInstance> {
    const logger = context.createLogger(this.name);
    // const [from, to] = this.portRange;
    const port = context.port || 3000;
    const mainFile = await this.getMainFile();   
    const contextVars = context.envVariables;
    const child = execFile(this.nodeBin, [mainFile], {
      cwd: context.hostRootDir,
      env: {
        ...process.env,
        ...contextVars,
        PORT: port.toString(),
      }
    }, (error) => {
      if (error) {
        // @todo: this is causing uncaughtException in the main process. a better way to handle this would be to use promise.
        // however, since it expects to return a number, it would require a bigger refactor.
        // eslint-disable-next-line @typescript-eslint/no-throw-literal
        throw error;
      }
    });
    child.stdout?.on('data', (data) => {
      if (!this.showNameInOutputs) return logger.console(`${data.toString()}`);
      logger.console(`[${this.name}]: ${data.toString()}`);
    });

    process.on('exit', () => {
      child.kill('SIGKILL');
    });
    
    return {
      appName: this.name,
      port
    };
  }

  private get outputDir() {
    return join(CAPSULE_ARTIFACTS_DIR, this.artifactName);
  }

  async build(context: AppBuildContext): Promise<AppBuildResult> {
    if (this.customBuild) return this.customBuild(context);
    const rootDir = context.capsule.path;
    const outputDir = join(rootDir, this.outputDir);
    const mainFile = await this.getMainFile();

    const result = await build({
      ...this.esbuildOptions,
      entryPoints: [mainFile],
      bundle: true,
      platform: 'node',
      outfile: join(outputDir, this.bundleFileName),
    });

    return {
      errors: result.errors.map((error) => {
        return new Error(error.detail);
      }),
      artifacts: [
        {
          name: this.artifactName,
          globPatterns: [this.outputDir],
        },
      ],
      metadata: {
        publicDir: this.outputDir
      }
    };
  }

  static from(options: NodeAppOptions) {
    return new NodeApp(
      options.name,
      options.mainPath,
      options.build,
      options.deploy
    );
  }
}
