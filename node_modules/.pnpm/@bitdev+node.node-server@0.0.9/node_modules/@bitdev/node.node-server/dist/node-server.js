"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeServer = void 0;
const esbuild_1 = require("esbuild");
const toolbox_network_get_port_1 = require("@teambit/toolbox.network.get-port");
const builder_1 = require("@teambit/builder");
const node_path_1 = require("node:path");
const workspace_1 = require("@teambit/workspace");
const lodash_1 = require("lodash");
const node_url_1 = require("node:url");
const start_plugin_js_1 = require("./start-plugin.js");
class NodeServer {
    constructor(name, mainFile, customBuild, deploy, nodeBin = 'node', artifactName = 'app-bundle', bundleFileName = `${name}.cjs`, esbuildOptions = {}, showNameInOutputs = true, distDir = 'dist', portRange = [5000, 5100]) {
        this.name = name;
        this.mainFile = mainFile;
        this.customBuild = customBuild;
        this.deploy = deploy;
        this.nodeBin = nodeBin;
        this.artifactName = artifactName;
        this.bundleFileName = bundleFileName;
        this.esbuildOptions = esbuildOptions;
        this.showNameInOutputs = showNameInOutputs;
        this.distDir = distDir;
        this.portRange = portRange;
        this.applicationType = 'node';
    }
    getFileUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = (0, node_url_1.fileURLToPath)(yield this.mainFile);
            return url;
        });
    }
    getMainFile(componentPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryFile = yield this.mainFile;
            const mainFile = entryFile.startsWith('file:')
                ? yield this.getFileUrl()
                : (0, node_path_1.resolve)(componentPath, entryFile);
            return mainFile;
        });
    }
    run(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const mainFile = yield this.getMainFile(context.workspaceComponentPath);
            const [fromPort, toPort] = this.portRange;
            const port = context.port || (yield toolbox_network_get_port_1.Port.getPort(fromPort, toPort));
            const envVars = this.computeEnvVars(Object.assign(Object.assign({}, context.envVariables), { PORT: port.toString() }));
            const root = context.hostRootDir;
            const outfile = (0, node_path_1.join)(root, this.distDir, this.bundleFileName);
            const packageIndex = yield this.computePackageMap(context);
            const config = this.computeConfig(mainFile, outfile, context.workspaceComponentPath, Object.assign({}, packageIndex), envVars);
            const esContext = yield (0, esbuild_1.context)(config);
            yield esContext.watch();
            return {
                port
            };
        });
    }
    computeEnvVars(envVars) {
        const keys = Object.keys(envVars);
        return keys.reduce((acc, key) => {
            const keyName = `process.env.${key}`;
            if (acc[keyName])
                return acc;
            acc[keyName] = `"${envVars[key]}"`;
            return acc;
        }, {});
    }
    computePackageMap(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const workspace = context.getAspect(workspace_1.WorkspaceAspect.id);
            const components = workspace ? yield workspace.list() : [];
            const packageListDist = (0, lodash_1.compact)(components.map((c) => [`${workspace === null || workspace === void 0 ? void 0 : workspace.componentPackageName(c)}/dist`, workspace.componentDir(c.id)]));
            const packageList = (0, lodash_1.compact)(components.map((c) => [workspace === null || workspace === void 0 ? void 0 : workspace.componentPackageName(c), workspace.componentDir(c.id)]));
            const allPackages = packageList.concat(packageListDist);
            const packageIndex = allPackages.reduce((acc, [packageName, dir]) => {
                if (acc[packageName])
                    return acc;
                acc[packageName] = dir;
                return acc;
            }, {});
            return packageIndex;
        });
    }
    computeConfig(mainFile, outFile, workDir, packageIndex, define) {
        return Object.assign({ platform: 'node', define, entryPoints: [mainFile], bundle: true, outfile: outFile, sourcemap: true, alias: packageIndex, plugins: [(0, start_plugin_js_1.startPlugin)(outFile)] }, this.esbuildOptions);
    }
    get outputDir() {
        return (0, node_path_1.join)(builder_1.CAPSULE_ARTIFACTS_DIR, this.artifactName);
    }
    build(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.customBuild)
                return this.customBuild(context);
            const rootDir = context.capsule.path;
            const outputDir = (0, node_path_1.join)(rootDir, this.outputDir);
            const mainFile = yield this.getMainFile(context.capsule.path);
            const result = yield (0, esbuild_1.build)(Object.assign(Object.assign({}, this.esbuildOptions), { entryPoints: [mainFile], bundle: true, platform: 'node', outfile: (0, node_path_1.join)(outputDir, this.bundleFileName) }));
            return {
                errors: result.errors.map((error) => {
                    return new Error(error.detail);
                }),
                artifacts: [
                    {
                        name: this.artifactName,
                        globPatterns: [this.outputDir],
                    },
                ],
                metadata: {
                    publicDir: this.outputDir
                }
            };
        });
    }
    static from(options) {
        return new NodeServer(options.name, options.mainPath, options.build, options.deploy, options.nodeBin, options.artifactName, options.bundleFileName, options.esbuildOptions, options.showNameInOutputs, options.distDir, options.portRange);
    }
}
exports.NodeServer = NodeServer;
//# sourceMappingURL=node-server.js.map