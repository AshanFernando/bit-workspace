import { build, BuildOptions, context as esbuild } from 'esbuild';
import { Port } from '@teambit/toolbox.network.get-port';
import { CAPSULE_ARTIFACTS_DIR } from '@teambit/builder';
import type { Application, DeployFn, AppContext, ApplicationInstance, BuildFn, AppBuildResult, AppBuildContext } from '@teambit/application';
import { join, resolve } from 'node:path';
import type { Workspace } from '@teambit/workspace';
import { WorkspaceAspect } from '@teambit/workspace';
import { compact } from 'lodash';
import { fileURLToPath } from 'node:url';
import type { NodeServerOptions } from './node-server-options.js';
import { startPlugin } from './start-plugin.js';

export class NodeServer implements Application {
  constructor(
    readonly name: string,
    readonly mainFile: Promise<string>|string,
    readonly customBuild?: BuildFn,
    readonly deploy?: DeployFn,
    readonly nodeBin: string = 'node',
    readonly artifactName: string = 'app-bundle',
    readonly bundleFileName: string = `${name}.cjs`,
    readonly esbuildOptions: BuildOptions = {},
    readonly showNameInOutputs = true,
    readonly distDir: string = 'dist',
    readonly portRange: [number, number] = [5000, 5100],
  ) {}

  applicationType = 'node';

  private async getFileUrl() {
    const url = fileURLToPath(await this.mainFile);
    return url;
  }

  private async getMainFile(componentPath: string) {
    const entryFile = await this.mainFile;
    const mainFile = entryFile.startsWith('file:')
      ? await this.getFileUrl()
      : resolve(componentPath, entryFile);
    return mainFile;
  }

  async run(context: AppContext): Promise<ApplicationInstance> {
    const mainFile = await this.getMainFile(context.workspaceComponentPath);
    const [fromPort, toPort] = this.portRange;
    const port = context.port || await Port.getPort(fromPort, toPort);
    const envVars = this.computeEnvVars({
      ...context.envVariables,
      PORT: port.toString()
    });

    const root = context.hostRootDir;
    const outfile = join(root, this.distDir, this.bundleFileName);
    const packageIndex = await this.computePackageMap(context);
    const config = this.computeConfig(mainFile, outfile, context.workspaceComponentPath, {
      ...packageIndex,
      // ...rootAlias
    }, envVars);

    const esContext = await esbuild(config);
    await esContext.watch();

    return {
      port
    };
  }

  private computeEnvVars(envVars: Record<string, string>) {
    const keys = Object.keys(envVars);
    return keys.reduce((acc, key) => {
      const keyName = `process.env.${key}`;
      if (acc[keyName]) return acc;
      acc[keyName] = `"${envVars[key]}"`;
      return acc;
    }, {});
  }

  private async computePackageMap(context: AppContext): Promise<Record<string, string>> {
    const workspace = context.getAspect<Workspace>(WorkspaceAspect.id);
    const components = workspace ? await workspace.list() : [];
    const packageListDist: [string, string][] = compact(
      components.map((c) => [`${workspace?.componentPackageName(c)}/dist`, workspace.componentDir(c.id)])
      );
    const packageList: [string, string][] = compact(
      components.map((c) => [workspace?.componentPackageName(c), workspace.componentDir(c.id)])
      );

    const allPackages = packageList.concat(packageListDist);
    
    const packageIndex = allPackages.reduce((acc, [packageName, dir]) => {
      if (acc[packageName]) return acc;
      acc[packageName] = dir;
      return acc;
    }, {});

    return packageIndex;
  }

  private computeConfig(mainFile: string, outFile: string, workDir: string, packageIndex: Record<string, string>, define?: Record<string, string>): BuildOptions {
    return {
      platform: 'node',
      define,
      entryPoints: [mainFile],
      bundle: true,
      outfile: outFile,
      sourcemap: true,
      alias: packageIndex,
      plugins: [startPlugin(outFile)],
      ...this.esbuildOptions
    };
  }

  private get outputDir() {
    return join(CAPSULE_ARTIFACTS_DIR, this.artifactName);
  }

  async build(context: AppBuildContext): Promise<AppBuildResult> {
    if (this.customBuild) return this.customBuild(context);
    const rootDir = context.capsule.path;
    const outputDir = join(rootDir, this.outputDir);
    const mainFile = await this.getMainFile(context.capsule.path);

    const result = await build({
      ...this.esbuildOptions,
      entryPoints: [mainFile],
      bundle: true,
      platform: 'node',
      outfile: join(outputDir, this.bundleFileName),
    });

    return {
      errors: result.errors.map((error) => {
        return new Error(error.detail);
      }),
      artifacts: [
        {
          name: this.artifactName,
          globPatterns: [this.outputDir],
        },
      ],
      metadata: {
        publicDir: this.outputDir
      }
    };
  }

  static from(options: NodeServerOptions) {
    return new NodeServer(
      options.name,
      options.mainPath,
      options.build,
      options.deploy,
      options.nodeBin,
      options.artifactName,
      options.bundleFileName,
      options.esbuildOptions,
      options.showNameInOutputs,
      options.distDir,
      options.portRange
    );
  }
}
