---
labels: ['runtime', 'apps', 'platforms', 'dev']
description: 'Composing backends and frontends.'
---

Use platform to create to stitch Bit apps into composable architectures.

## Get started

```
bit create platform acme-platform
```

This command will create a new platform component, using two servers

### Compose backend and frontend

Compose a backend and a frontend by creating a platform and returning it as a bit app:

```ts
import { Platform } from '@bitdev/platforms.platform';

const AcmeWeb = import.meta.resolve('@bitdev/platforms.examples.acme-web');
const UserServer = import.meta.resolve('@bitdev/node.examples.user-server');

export const AcmePlatform = Platform.from({
  name: 'acme-platform',

  frontends: {
    main: AcmeWeb,
  },

  backends: {
    main: UserServer,
  },
});
```

You can control port ranges by using the `portRange` option on either on your backend and frontend.

### Compose a micro-frontend architecture

Use the `services` option to compose a service architecture for either your frontend or backend:

```ts
import { Platform } from '@bitdev/platforms.platform';

const AcmeWeb = import.meta.resolve('@bitdev/platforms.examples.acme-web');
const AcmeGateway = import.meta.resolve('./acme-gateway.js');
const UserServer = import.meta.resolve('@bitdev/node.examples.user-server');
const DiscussionServer = import.meta.resolve('@bitdev/platforms.examples.discussion-server');

export const AcmePlatform = Platform.from({
  name: 'acme-platform',

  backends: {
    main: AcmeGateway,
    services: [
      [UserServer, {
        remoteUrl: 'http://acme.com:8080',
      }],
      DiscussionServer,
    ],
  },
});
```

## Using remote URLs

You can configure services using tupples to add a remote URL to use in case the component is not present in your workspace:

```ts
export const AcmePlatform = Platform.from({
  name: 'acme-platform',

  backends: {
    main: AcmeGateway,
    services: [
      [UserServer, {
        remoteUrl: 'http://users.acme.com',
      }],
    ],
  },
});
```

You can use the `forceRemote` option to force a service to be used remotely even in cases the service exist locally.

## Build

You can add a build function by pass it to the `build` option and:

```ts
import { build } from 'esbuild';

export async function build(context: PlatformBuildContext): Promise<AppBuildResult> {
  const platformComponents = context.platformComponents;
  const path = import.meta.resolve('./gateway');
  const results = await build({
    entryPoints: [path],
    bundle: true,
    platform: 'node'
  })
}
```

Learn more on build app [build tasks](https://bit.dev/reference/apps/build-apps).

## Deploy

You can deploy platform specific deployment logic by implemeting the `deploy` function, the example above demonstrates executing a command:

```ts
import { exec } from 'node:child_process';

export function deploy(context: PlatformBuildContext): Promise<AppBuildResult> {  
  const response = exec(`s3-upload ${context}`);
}
```

Learn more on build app [build tasks](https://bit.dev/reference/apps/build-apps).

## More composable patterns

Looking to compose using Aspects? Try [Harmony](https://bit.cloud/bitdev/harmony) out.
