import { AppContext } from "@teambit/application";
import { ComponentID } from "@teambit/component-id";
import findRoot from "find-root";
import { Port } from "@teambit/toolbox.network.get-port";
import { existsSync, readFileSync } from "fs";
import { join } from "path";
import { WorkspaceAspect } from "@teambit/workspace";
import { ScopeAspect } from "@teambit/scope";
import { BuilderAspect } from "@teambit/builder";
import { ComponentAspect } from "@teambit/component";
import { fileURLToPath, pathToFileURL } from "node:url";
import { GatewayContext } from "./gateway-context.js";
export class Platform {
    constructor(
    /**
     * name of the platform
     */
    name, 
    /**
     * backends of the platform.
     */
    backends, 
    /**
     * frontends of the platform
     */
    frontends, 
    /**
     * custom build function.
     */
    userBuild, 
    /**
     * custom deploy function.
     */
    userDeploy) {
        this.name = name;
        this.backends = backends;
        this.frontends = frontends;
        this.userBuild = userBuild;
        this.userDeploy = userDeploy;
    }
    async run(context) {
        const backend = await this.runPlatformLayer("backend", context, this.backends);
        // const frontend = await this.runPlatformLayer('frontend', context, this.frontends, backend);
        const frontends = this.frontends.mainPortRange
            ? this.frontends
            : { ...this.frontends, mainPortRange: [3000, 3100] };
        await this.runPlatformLayer("frontend", context, frontends, backend);
        const isPort = typeof backend === "number";
        const port = isPort ? backend : backend.port;
        return {
            appName: this.name,
            port,
        };
    }
    listPlatformModules(platformLayer, context, mainPort) {
        const [from, to] = platformLayer.portRange || [5000, 5100];
        const usedPorts = mainPort ? [mainPort] : undefined;
        return Promise.all(platformLayer.services?.map(async (service) => {
            const targetPort = usedPorts
                ? await Port.getPort(from, to, usedPorts)
                : undefined;
            const platformServiceModule = await this.loadPlatformService(service, targetPort, context);
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            usedPorts && usedPorts.push(targetPort);
            return platformServiceModule;
        }) || []);
    }
    async runPlatformLayer(name, context, platformLayer, apiGateway) {
        if (!platformLayer)
            return {};
        const [from, to] = platformLayer.portRange || [5000, 5100];
        const [gatewayFrom, gatewayTo] = platformLayer.mainPortRange || [from, to];
        const gatewayPort = await Port.getPort(gatewayFrom, gatewayTo);
        const platformServiceModules = (await this.listPlatformModules(platformLayer, context, gatewayPort)) ||
            [];
        const serviceEnvVars = this.computeEnvVars(platformServiceModules.map((serviceModule) => {
            return {
                appName: serviceModule?.module?.name || serviceModule.componentId.name,
                port: serviceModule.context.port,
            };
        }));
        const instances = await Promise.all(platformServiceModules.map(async (platformService) => {
            if (platformService.url) {
                return {
                    appName: platformService.module.name,
                    url: platformService.url,
                };
            }
            const platformContext = AppContext.compose(platformService.context, {
                envVariables: serviceEnvVars,
            });
            const appInstance = await platformService.module.run(platformContext);
            const isNumber = typeof appInstance === "number";
            const appName = platformService.module.name;
            const port = isNumber ? appInstance : appInstance.port;
            if (port) {
                let retries = 0;
                while (retries < 10) {
                    try {
                        await fetch(`http://localhost:${port}`);
                        break;
                    }
                    catch (e) {
                        retries++;
                        await new Promise((resolve) => setTimeout(resolve, 1000));
                    }
                }
                if (retries === 10) {
                    throw new Error(`service ${appName} did not start after 10 retries.`);
                }
            }
            console.log(`[${platformService.module.name}]: running on port ${port}`);
            return {
                appName,
                port,
            };
        }) || []);
        const mainService = await this.loadPlatformService(platformLayer.main, gatewayPort, context);
        const envVars = this.computeEnvVars(apiGateway ? instances.concat([apiGateway]) : instances, apiGateway);
        const gatewayContext = new GatewayContext(mainService.context, instances, gatewayPort, envVars);
        const gatewayInstance = await mainService.module.run(gatewayContext);
        console.log(`${name} server running on ${gatewayContext.port}`);
        return this.getAppInstance(gatewayInstance, mainService);
    }
    computeEnvVars(instances, apiGateway) {
        return instances.reduce((acc, instance) => {
            if (apiGateway && !acc?.BACKEND_URL) {
                acc.BACKEND_URL = instance.url || `http://localhost:${instance.port}`;
            }
            if (!instance?.appName) {
                console.warn(`warning: there is a server listening to port ${instance.port} but without an app name specified. an env variable would not be set.`);
                return acc;
            }
            // @ts-ignore-next-line
            const varName = `${instance.appName.toUpperCase()}_URL`.replaceAll("-", "_");
            acc[varName] = instance.url || `http://localhost:${instance.port}`;
            return acc;
        }, {});
    }
    getAppInstance(res, service) {
        if (typeof res !== "number") {
            const appName = res.appName || service.name;
            return {
                appName,
                ...res,
            };
        }
        return {
            appName: service.name,
            port: res,
        };
    }
    getWorkspace(context) {
        try {
            const workspace = context.getAspect(WorkspaceAspect.id);
            return workspace;
        }
        catch {
            return undefined;
        }
    }
    async getComponent(context, id) {
        const scope = context.getAspect(ScopeAspect.id);
        const componentAspect = context.getAspect(ComponentAspect.id);
        const host = componentAspect.getHost();
        const hasId = await host.hasIdNested(id);
        if (hasId) {
            return host.get(id);
        }
        await scope.import([id]);
        return host.get(id);
    }
    async loadPlatformService(serviceOpts, targetPort, context) {
        const workspace = this.getWorkspace(context);
        // const componentAspect = context.getAspect<ComponentMain>(ComponentAspect.id);
        // const host = componentAspect.getHost();
        const hasOpts = Array.isArray(serviceOpts);
        const servicePath = hasOpts ? await serviceOpts[0] : await serviceOpts;
        const options = hasOpts ? serviceOpts[1] : {};
        const urlPath = fileURLToPath(servicePath);
        const root = await findRoot(urlPath);
        const packageJsonString = readFileSync(join(root, "package.json")).toString("utf-8");
        const packageJson = JSON.parse(packageJsonString);
        const componentId = ComponentID.fromObject(packageJson.componentId);
        const isSelf = context.appComponent.id.toStringWithoutVersion() ===
            componentId.toStringWithoutVersion();
        const isInWorkspace = workspace
            ? await workspace.hasId(componentId)
            : false;
        const shouldReturnRemote = (options.forceRemote && options.remoteUrl) ||
            (!isInWorkspace && Boolean(options.remoteUrl)) ||
            !workspace;
        const remoteUrl = shouldReturnRemote ? options.remoteUrl : undefined;
        const packageName = packageJson.name;
        const workspacePath = isInWorkspace
            ? workspace.componentDir(componentId)
            : root;
        const appComponent = await this.getComponent(context, componentId);
        const serviceContext = AppContext.compose(context, {
            port: targetPort,
            workspaceComponentPath: workspacePath,
            hostRootDir: root,
            appComponent,
        });
        const path = isSelf
            ? urlPath
            : this.findBitApp(context, componentId, root, packageJson.main);
        const serviceModule = await import(pathToFileURL(path).href);
        let service = serviceModule.default;
        // check for commonjs module, as it exports the default to module.default.default
        if (service.default) {
            service = service.default;
        }
        if (!serviceModule.default)
            throw new Error(`service in path ${path} has no "export default".`);
        const serviceName = service.name;
        return {
            module: service,
            context: serviceContext,
            url: remoteUrl,
            name: serviceName,
            componentId,
            packageName,
        };
    }
    findBitApp(context, id, root, main) {
        const compiler = context.env.getCompiler();
        const distDir = compiler.getDistDir?.() || "dist";
        const possibleLocations = [
            join(root, distDir, `${id.name}.bit-app.js`),
            join(root, distDir, `${id.name}.bit-app.mjs`),
            join(root, main),
        ];
        return possibleLocations.find((possiblePath) => {
            return existsSync(possiblePath);
        });
    }
    async createPlatformContext(context) {
        const scope = context.getAspect(ScopeAspect.id);
        const builder = context.getAspect(BuilderAspect.id);
        const backendPlatformModules = await this.listPlatformModules(this.backends, context);
        const frontendPlatformModules = await this.listPlatformModules(this.frontends, context);
        const platformServicesModules = [
            ...backendPlatformModules,
            ...frontendPlatformModules,
        ];
        const componentIds = platformServicesModules.map((platformModule) => {
            return platformModule.componentId;
        });
        const components = await scope.getMany(componentIds);
        const platformServices = platformServicesModules.map((platformService) => {
            const platformComponent = components.find((component) => {
                return (component.id.toStringWithoutVersion() ===
                    platformService.componentId.toStringWithoutVersion());
            });
            const artifacts = builder.getArtifacts(platformComponent);
            const isBackend = backendPlatformModules.find((backend) => {
                return (backend.componentId.toStringWithoutVersion() ===
                    platformService.componentId.toStringWithoutVersion());
            });
            return {
                type: isBackend ? "backend" : "frontend",
                componentId: platformService.componentId,
                artifacts,
                name: platformService.name,
                url: platformService.url,
                component: platformComponent,
            };
        });
        const mainBackend = await this.loadPlatformService(this.backends.main, context.port, context).then(async (backend) => {
            const component = await scope.get(backend.componentId);
            return {
                type: "backend",
                componentId: backend.componentId,
                name: backend.name,
                url: backend.url,
                component: component,
                artifacts: builder.getArtifacts(component),
            };
        });
        const mainFrontend = await this.loadPlatformService(this.frontends.main, context.port, context).then(async (frontend) => {
            const component = await scope.get(frontend.componentId);
            return {
                type: "frontend",
                componentId: frontend.componentId,
                name: frontend.name,
                url: frontend.url,
                component: component,
                artifacts: builder.getArtifacts(component),
            };
        });
        const platformContext = Object.assign(context, {
            platformServices,
            mainFrontend,
            mainBackend,
        });
        return platformContext;
    }
    async build(context) {
        if (!this.userBuild)
            return {};
        const platformContext = await this.createPlatformContext(context);
        return this.userBuild(platformContext);
    }
    async deploy(context) {
        if (!this.userDeploy)
            return {};
        const platformContext = await this.createPlatformContext(context);
        return this.userDeploy(platformContext);
    }
    static from(options) {
        return new Platform(options.name, options.backends, options.frontends, options.build, options.deploy);
    }
}
//# sourceMappingURL=platform.js.map