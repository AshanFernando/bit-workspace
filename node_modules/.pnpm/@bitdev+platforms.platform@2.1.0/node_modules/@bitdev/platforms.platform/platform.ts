import type {
	AppBuildContext,
	AppDeployContext,
	Application,
	ApplicationInstance,
} from "@teambit/application";
import { AppContext } from "@teambit/application";
import { ComponentID } from "@teambit/component-id";
import findRoot from "find-root";
import { Port } from "@teambit/toolbox.network.get-port";
import { existsSync, readFileSync } from "fs";
import { join } from "path";
import type { Compiler } from "@teambit/compiler";
import type { Workspace } from "@teambit/workspace";
import { WorkspaceAspect } from "@teambit/workspace";
import { ScopeAspect, ScopeMain } from "@teambit/scope";
import { BuilderAspect, BuilderMain } from "@teambit/builder";
import type { Component, ComponentMain } from "@teambit/component";
import { ComponentAspect } from "@teambit/component";
import { fileURLToPath, pathToFileURL } from "node:url";
import {
	PlatformBuildFn,
	PlatformDeployFn,
	PlatformOptions,
} from "./platform-options.js";
import { GatewayContext } from "./gateway-context.js";
import { PlatformService, PlatformServiceModule } from "./platform-service.js";
import { PlatformLayer } from "./platform-layer.js";
import { PlatformBuildContext } from "./platform-build-context.js";

export class Platform implements Application {
	constructor(
		/**
		 * name of the platform
		 */
		readonly name: string,

		/**
		 * backends of the platform.
		 */
		readonly backends: PlatformLayer,

		/**
		 * frontends of the platform
		 */
		readonly frontends: PlatformLayer,

		/**
		 * custom build function.
		 */
		readonly userBuild?: PlatformBuildFn,

		/**
		 * custom deploy function.
		 */
		readonly userDeploy?: PlatformDeployFn,
	) {}

	async run(context: AppContext): Promise<ApplicationInstance> {
		const backend = await this.runPlatformLayer(
			"backend",
			context,
			this.backends,
		);
		// const frontend = await this.runPlatformLayer('frontend', context, this.frontends, backend);
		const frontends = this.frontends.mainPortRange
			? this.frontends
			: { ...this.frontends, mainPortRange: [3000, 3100] as [number, number] };

		await this.runPlatformLayer("frontend", context, frontends, backend);

		const isPort = typeof backend === "number";
		const port = isPort ? backend : backend.port;

		return {
			appName: this.name,
			port,
		};
	}

	private listPlatformModules(
		platformLayer: PlatformLayer,
		context: AppContext,
		mainPort?: number,
	): Promise<PlatformServiceModule[]> {
		const [from, to] = platformLayer.portRange || [5000, 5100];
		const usedPorts = mainPort ? [mainPort] : undefined;

		return Promise.all(
			platformLayer.services?.map(async (service) => {
				const targetPort = usedPorts
					? await Port.getPort(from, to, usedPorts)
					: undefined;
				const platformServiceModule = await this.loadPlatformService(
					service,
					targetPort,
					context,
				);
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				usedPorts && usedPorts.push(targetPort);
				return platformServiceModule;
			}) || [],
		);
	}

	async runPlatformLayer(
		name: string,
		context: AppContext,
		platformLayer: PlatformLayer,
		apiGateway?: ApplicationInstance,
	): Promise<ApplicationInstance> {
		if (!platformLayer) return {};
		const [from, to] = platformLayer.portRange || [5000, 5100];
		const [gatewayFrom, gatewayTo] = platformLayer.mainPortRange || [from, to];
		const gatewayPort = await Port.getPort(gatewayFrom, gatewayTo);
		const platformServiceModules =
			(await this.listPlatformModules(platformLayer, context, gatewayPort)) ||
			[];
		const serviceEnvVars = this.computeEnvVars(
			platformServiceModules.map((serviceModule) => {
				return {
					appName:
						serviceModule?.module?.name || serviceModule.componentId.name,
					port: serviceModule.context.port,
				};
			}),
		);

		const instances: ApplicationInstance[] = await Promise.all(
			platformServiceModules.map(async (platformService) => {
				if (platformService.url) {
					return {
						appName: platformService.module.name,
						url: platformService.url,
					};
				}

				const platformContext = AppContext.compose(platformService.context, {
					envVariables: serviceEnvVars,
				});
				const appInstance = await platformService.module.run(platformContext);
				const isNumber = typeof appInstance === "number";
				const appName = platformService.module.name;
				const port = isNumber ? appInstance : appInstance.port;

				if (port) {
					let retries = 0;
					while (retries < 10) {
						try {
							await fetch(`http://localhost:${port}`);
							break;
						} catch (e) {
							retries++;
							await new Promise((resolve) => setTimeout(resolve, 1000));
						}
					}
					if (retries === 10) {
						throw new Error(
							`service ${appName} did not start after 10 retries.`,
						);
					}
				}

				console.log(
					`[${platformService.module.name}]: running on port ${port}`,
				);

				return {
					appName,
					port,
				};
			}) || [],
		);

		const mainService = await this.loadPlatformService(
			platformLayer.main,
			gatewayPort,
			context,
		);
		const envVars = this.computeEnvVars(
			apiGateway ? instances.concat([apiGateway]) : instances,
			apiGateway,
		);

		const gatewayContext = new GatewayContext(
			mainService.context,
			instances,
			gatewayPort,
			envVars,
		);

		const gatewayInstance = await mainService.module.run(gatewayContext);
		console.log(`${name} server running on ${gatewayContext.port}`);
		return this.getAppInstance(gatewayInstance, mainService);
	}

	private computeEnvVars(
		instances: ApplicationInstance[],
		apiGateway?: ApplicationInstance,
	): Record<string, string> {
		return instances.reduce<Record<string, string>>((acc, instance) => {
			if (apiGateway && !acc?.BACKEND_URL) {
				acc.BACKEND_URL = instance.url || `http://localhost:${instance.port}`;
			}

			if (!instance?.appName) {
				console.warn(
					`warning: there is a server listening to port ${instance.port} but without an app name specified. an env variable would not be set.`,
				);
				return acc;
			}
			// @ts-ignore-next-line
			const varName = `${instance.appName.toUpperCase()}_URL`.replaceAll(
				"-",
				"_",
			);
			acc[varName] = instance.url || `http://localhost:${instance.port}`;
			return acc;
		}, {});
	}

	getAppInstance(
		res: number | ApplicationInstance,
		service?: PlatformServiceModule,
	) {
		if (typeof res !== "number") {
			const appName = res.appName || service.name;

			return {
				appName,
				...res,
			};
		}

		return {
			appName: service.name,
			port: res,
		};
	}

	private getWorkspace(context: AppContext): Workspace | undefined {
		try {
			const workspace = context.getAspect<Workspace>(WorkspaceAspect.id);
			return workspace;
		} catch {
			return undefined;
		}
	}

	async getComponent(context: AppContext, id: ComponentID): Promise<Component> {
		const scope = context.getAspect<ScopeMain>(ScopeAspect.id);
		const componentAspect = context.getAspect<ComponentMain>(
			ComponentAspect.id,
		);
		const host = componentAspect.getHost();
		const hasId = await host.hasIdNested(id);

		if (hasId) {
			return host.get(id);
		}

		await scope.import([id]);
		return host.get(id);
	}

	async loadPlatformService(
		serviceOpts: PlatformService,
		targetPort: number,
		context: AppContext,
	): Promise<PlatformServiceModule> {
		const workspace = this.getWorkspace(context);
		// const componentAspect = context.getAspect<ComponentMain>(ComponentAspect.id);
		// const host = componentAspect.getHost();
		const hasOpts = Array.isArray(serviceOpts);
		const servicePath = hasOpts ? await serviceOpts[0] : await serviceOpts;

		const options = hasOpts ? serviceOpts[1] : {};

		const urlPath = fileURLToPath(servicePath);
		const root = await findRoot(urlPath);
		const packageJsonString = readFileSync(join(root, "package.json")).toString(
			"utf-8",
		);
		const packageJson = JSON.parse(packageJsonString);
		const componentId = ComponentID.fromObject(packageJson.componentId);
		const isSelf =
			context.appComponent.id.toStringWithoutVersion() ===
			componentId.toStringWithoutVersion();
		const isInWorkspace = workspace
			? await workspace.hasId(componentId)
			: false;
		const shouldReturnRemote =
			(options.forceRemote && options.remoteUrl) ||
			(!isInWorkspace && Boolean(options.remoteUrl)) ||
			!workspace;

		const remoteUrl = shouldReturnRemote ? options.remoteUrl : undefined;

		const packageName = packageJson.name;
		const workspacePath = isInWorkspace
			? workspace.componentDir(componentId)
			: root;

		const appComponent = await this.getComponent(context, componentId);

		const serviceContext = AppContext.compose(context, {
			port: targetPort,
			workspaceComponentPath: workspacePath,
			hostRootDir: root,
			appComponent,
		});

		const path = isSelf
			? urlPath
			: this.findBitApp(context, componentId, root, packageJson.main);

		const serviceModule = await import(pathToFileURL(path).href);
		let service = serviceModule.default;
		// check for commonjs module, as it exports the default to module.default.default
		if (service.default) {
			service = service.default;
		}

		if (!serviceModule.default)
			throw new Error(`service in path ${path} has no "export default".`);
		const serviceName = service.name;

		return {
			module: service,
			context: serviceContext,
			url: remoteUrl,
			name: serviceName,
			componentId,
			packageName,
		};
	}

	private findBitApp(
		context: AppContext,
		id: ComponentID,
		root: string,
		main: string,
	) {
		const compiler: Compiler = context.env.getCompiler();
		const distDir = compiler.getDistDir?.() || "dist";
		const possibleLocations = [
			join(root, distDir, `${id.name}.bit-app.js`),
			join(root, distDir, `${id.name}.bit-app.mjs`),
			join(root, main),
		];

		return possibleLocations.find((possiblePath) => {
			return existsSync(possiblePath);
		});
	}

	private async createPlatformContext(
		context: AppBuildContext,
	): Promise<PlatformBuildContext> {
		const scope = context.getAspect<ScopeMain>(ScopeAspect.id);
		const builder = context.getAspect<BuilderMain>(BuilderAspect.id);
		const backendPlatformModules = await this.listPlatformModules(
			this.backends,
			context,
		);
		const frontendPlatformModules = await this.listPlatformModules(
			this.frontends,
			context,
		);
		const platformServicesModules = [
			...backendPlatformModules,
			...frontendPlatformModules,
		];

		const componentIds = platformServicesModules.map((platformModule) => {
			return platformModule.componentId;
		});

		const components = await scope.getMany(componentIds);
		const platformServices = platformServicesModules.map((platformService) => {
			const platformComponent = components.find((component) => {
				return (
					component.id.toStringWithoutVersion() ===
					platformService.componentId.toStringWithoutVersion()
				);
			});
			const artifacts = builder.getArtifacts(platformComponent);
			const isBackend = backendPlatformModules.find((backend) => {
				return (
					backend.componentId.toStringWithoutVersion() ===
					platformService.componentId.toStringWithoutVersion()
				);
			});

			return {
				type: isBackend ? "backend" : "frontend",
				componentId: platformService.componentId,
				artifacts,
				name: platformService.name,
				url: platformService.url,
				component: platformComponent,
			};
		});

		const mainBackend = await this.loadPlatformService(
			this.backends.main,
			context.port,
			context,
		).then(async (backend) => {
			const component = await scope.get(backend.componentId);
			return {
				type: "backend",
				componentId: backend.componentId,
				name: backend.name,
				url: backend.url,
				component: component,
				artifacts: builder.getArtifacts(component),
			};
		});

		const mainFrontend = await this.loadPlatformService(
			this.frontends.main,
			context.port,
			context,
		).then(async (frontend) => {
			const component = await scope.get(frontend.componentId);
			return {
				type: "frontend",
				componentId: frontend.componentId,
				name: frontend.name,
				url: frontend.url,
				component: component,
				artifacts: builder.getArtifacts(component),
			};
		});

		const platformContext = Object.assign(context, {
			platformServices,
			mainFrontend,
			mainBackend,
		});

		return platformContext;
	}

	async build(context: AppBuildContext) {
		if (!this.userBuild) return {};
		const platformContext = await this.createPlatformContext(context);

		return this.userBuild(platformContext);
	}

	async deploy(context: AppDeployContext) {
		if (!this.userDeploy) return {};
		const platformContext = await this.createPlatformContext(context);

		return this.userDeploy(platformContext);
	}

	static from(options: PlatformOptions) {
		return new Platform(
			options.name,
			options.backends,
			options.frontends,
			options.build,
			options.deploy,
		);
	}
}
