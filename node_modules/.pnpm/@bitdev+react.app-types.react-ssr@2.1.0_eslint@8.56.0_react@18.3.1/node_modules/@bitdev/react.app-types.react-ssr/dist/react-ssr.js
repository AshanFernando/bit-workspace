import "react-refresh";
import "esbuild";
import { CAPSULE_ARTIFACTS_DIR } from "@teambit/builder";
import WDS from "webpack-dev-server";
import { join, isAbsolute } from "node:path";
import { writeFileSync } from "node:fs";
import { compact } from "lodash-es";
import { Port } from "@teambit/toolbox.network.get-port";
import webpack from "webpack";
import { WebpackConfigMutator } from "@teambit/webpack.modules.config-mutator";
import createConfig from "./webpack.config.cjs";
import createServerConfig from "./webpack.server.config.cjs";
import createBuildConfig from "./webpack.build.config.cjs";
import { createSsrApp } from "./create-ssr-app.js";
import { generateHtmlTemplate } from "./generate-html.js";
import { runTransformersWithContext, } from "./run-transformers.js";
import { createRequire } from "node:module";
const require = createRequire(import.meta.url);
export class ReactSsr {
    constructor(
    /**
     * name of the app.
     */
    name = "react-ssr", 
    /**
     * entries
     */
    // readonly entries: string[]|undefined = undefined,
    /**
     * filename for the bundle target.
     */
    filename = "bundle.js", 
    /**
     * default port for the dev server and preview.
     */
    portRange = [3000, 3200], 
    /**
     * path for the output of webpack on the component filesystem.
     */
    publicPath = "/public/", 
    /**
     * path to write server bundle.
     */
    serverPath = "/server/", 
    /**
     * webpack config. overrides default react config.
     * used for development purposes only via Webpack Dev Server (WDS).
     */
    transformers, 
    /**
     * name of the artifact.
     */
    artifactName = "app-bundle", 
    /**
     * root for the server.
     */
    serverRoot = "server.app-root.js", 
    /**
     * relative path to distribution dir.
     * default is: dist
     */
    compileOutDir = "dist", 
    /**
     * root for the client.
     */
    clientRoot = "client.app-root.js", 
    /**
     * deploy task
     */
    deploy, 
    /**
     * use a custom index.html path in the app.
     */
    indexHtml, 
    /**
     * determine whether to use ssr.
     */
    ssr = true, 
    /**
     * target exec file.
     */
    execFile = "server.cjs") {
        this.name = name;
        this.filename = filename;
        this.portRange = portRange;
        this.publicPath = publicPath;
        this.serverPath = serverPath;
        this.transformers = transformers;
        this.artifactName = artifactName;
        this.serverRoot = serverRoot;
        this.compileOutDir = compileOutDir;
        this.clientRoot = clientRoot;
        this.deploy = deploy;
        this.indexHtml = indexHtml;
        this.ssr = ssr;
        this.execFile = execFile;
    }
    /**
     * runs the app local dev server.
     * supports SSR.
     */
    async run(context) {
        const [fromPort, toPort] = this.portRange;
        const port = Number.isNaN(context.port)
            ? await Port.getPort(fromPort, toPort)
            : context.port;
        const componentDir = context.hostRootDir;
        const publicDir = join(context.hostRootDir, this.publicPath);
        const serverDir = join(context.hostRootDir, this.serverPath);
        // const entries = this.entries || [
        //   this.resolveFromDist(componentDir)
        // ];
        const entries = !isAbsolute(this.clientRoot)
            ? [
                require.resolve(join(componentDir, this.compileOutDir, this.clientRoot)),
            ]
            : [this.clientRoot];
        const htmlPath = !this.ssr ? this.getIndexHtml(componentDir) : undefined;
        const options = {
            outputPath: publicDir,
            publicPath: this.ssr ? this.publicPath : undefined,
            filename: this.filename,
            envVars: context.envVariables,
            entries,
            port,
            htmlPath,
        };
        const serverEntry = !isAbsolute(this.serverRoot)
            ? require.resolve(join(componentDir, this.compileOutDir, this.serverRoot))
            : this.serverRoot;
        const webpackConfig = this.transform(createConfig(options), {
            dev: true,
            appName: this.name,
            ssr: false,
        });
        const serverConfig = this.transform(createServerConfig({
            entries: [serverEntry],
            filename: "server.cjs",
            outputPath: serverDir,
            envVars: context.envVariables,
            serverEntry,
        }), {
            dev: false,
            ssr: true,
            appName: this.name,
        });
        const serverCompiler = webpack(serverConfig);
        if (this.ssr) {
            const clientCompiler = webpack(webpackConfig);
            serverCompiler.watch({}, () => { });
            const expressApp = createSsrApp([clientCompiler], {
                outputPath: this.publicPath,
                publicDir,
                publicPath: this.publicPath,
                app: join(serverDir, "server.cjs"),
                indexHtmlPath: this.getIndexHtml(componentDir),
                serverDir,
            });
            expressApp.listen(port, () => {
                console.log(`ðŸš€  Server ready at: http://localhost:${port}`);
            });
        }
        else {
            const clientCompiler = webpack(webpackConfig);
            const webpackDevServer = new WDS({
                ...webpackConfig.devServer,
                port,
            }, clientCompiler);
            await webpackDevServer.start();
        }
        return {
            appName: this.name,
            port,
        };
    }
    getIndexHtml(rootPath) {
        if (this.indexHtml)
            return this.indexHtml;
        return join(rootPath, "dist", "index.html");
    }
    get outputDir() {
        return join(CAPSULE_ARTIFACTS_DIR, this.artifactName);
    }
    get execFilePath() {
        return join(this.outputDir, this.execFile);
    }
    async runBuild(compiler) {
        return new Promise((resolveFn, reject) => {
            compiler.run((err, stats) => {
                if (err)
                    return reject(err);
                if (stats?.compilation?.errors?.length) {
                    const fieldsToShow = [
                        "message",
                        "moduleId",
                        "moduleName",
                        "moduleIdentifier",
                        "loc",
                    ];
                    const errors = stats.compilation?.errors?.map((error) => {
                        const lines = fieldsToShow.map((fieldName) => {
                            if (error[fieldName]) {
                                return `${fieldName}: ${error[fieldName]}`;
                            }
                            return undefined;
                        });
                        const errorMessage = compact(lines).join("\n");
                        return new Error(errorMessage);
                    });
                    return reject(errors);
                }
                return resolveFn(stats);
            });
        });
    }
    transform(config, context) {
        const clientConfigMutator = new WebpackConfigMutator(config);
        const mutatedClientConfig = runTransformersWithContext(clientConfigMutator.clone(), this.transformers, context);
        return mutatedClientConfig.raw;
    }
    async build(context) {
        const componentDir = context.capsule.path;
        const outputDir = join(componentDir, this.outputDir);
        const publicDir = join(outputDir, this.publicPath);
        const appEntry = !isAbsolute(this.serverRoot)
            ? require.resolve(join(componentDir, this.compileOutDir, this.serverRoot))
            : this.serverRoot;
        const clientEntry = !isAbsolute(this.clientRoot)
            ? require.resolve(join(componentDir, this.compileOutDir, this.clientRoot))
            : this.clientRoot;
        const webpackConfig = this.transform(createBuildConfig({
            entries: [clientEntry],
            publicPath: this.publicPath,
            envVars: context.envVariables,
            name: this.filename,
            outputPath: publicDir,
        }, true, false), {
            appName: this.name,
            dev: false,
            ssr: false,
        });
        const ssrConfig = this.transform(createBuildConfig({
            entries: [appEntry],
            name: "ssr",
            envVars: context.envVariables,
            filename: "ssr.cjs",
            outputPath: outputDir,
        }, true), {
            appName: this.name,
            dev: false,
            ssr: true,
        });
        const serverConfig = this.transform(createBuildConfig({
            entries: [require.resolve("./server-runner.js")],
            name: "server",
            envVars: context.envVariables,
            filename: this.execFile,
            outputPath: outputDir,
        }, true), {
            appName: this.name,
            dev: false,
            ssr: true,
        });
        const runnerServer = webpack([
            serverConfig,
            webpackConfig,
            ssrConfig,
        ]);
        const results = await this.runBuild(runnerServer);
        const htmlTemplate = await generateHtmlTemplate({
            publicDir,
            publicPath: "/",
            indexHtmlPath: this.getIndexHtml(componentDir),
        });
        writeFileSync(join(outputDir, "index.html"), htmlTemplate);
        console.log(results?.toString());
        return {
            artifacts: [
                {
                    name: this.artifactName,
                    globPatterns: [this.outputDir],
                },
            ],
            metadata: {
                publicDir: this.outputDir,
            },
        };
    }
    static from(options) {
        return new ReactSsr(options.name, options.filename, options.defaultPort, options.publicPath, undefined, options.transformers || [], options.artifactName, options.serverRoot, options.compileOutDir, options.clientRoot, options.deploy, options.indexHtml, options.ssr);
    }
}
//# sourceMappingURL=react-ssr.js.map