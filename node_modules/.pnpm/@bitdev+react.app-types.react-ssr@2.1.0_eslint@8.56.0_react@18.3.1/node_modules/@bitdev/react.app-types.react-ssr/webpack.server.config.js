const WebpackAssetsManifest = require('webpack-assets-manifest');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const webpack = require('webpack');
const { createStyleLoaders } = require('./create-style-loaders');

const imageInlineSizeLimit = parseInt(
  process.env.IMAGE_INLINE_SIZE_LIMIT || '10000', 10
);

module.exports = (options)  => {
  return {
    name: 'server',
    // ...options,
    mode: 'development',
    target: 'node',
    // watch: true,
    output: {
      path: options.outputPath,
      // publicPath: 'server',
      filename: options.filename || 'bundle.js',
      libraryTarget: 'commonjs',
    },
    entry: [...options.entries],
    plugins: [
      new webpack.DefinePlugin({
        'process.env': JSON.stringify(options.envVars)
      }),
      new WebpackAssetsManifest(),
      new MiniCssExtractPlugin({
        // Options similar to the same options in webpackOptions.output
        // both options are optional
        filename: 'static/css/[name].[contenthash:8].css',
        chunkFilename: 'static/css/[name].[contenthash:8].chunk.css',
      }),
      // new webpack.HotModuleReplacementPlugin(),
      // new webpack.WatchIgnorePlugin({
      //   paths: [/\.js$/, /\.d\.ts$/],
      // }),
      // new RunScriptWebpackPlugin({ name: options.filename, cwd: options.outputPath }),
    ],
    module: {
      rules: [
        {
          test: /\.m?js/,
          resolve: {
            fullySpecified: false,
          },
        },
        // "postcss" loader applies autoprefixer to our CSS.
        // "css" loader resolves paths in CSS and adds assets as dependencies.
        // "style" loader turns CSS into JS modules that inject <style> tags.
        // In production, we use MiniCSSExtractPlugin to extract that CSS
        // to a file, but in development "style" loader enables hot editing
        // of CSS.
        // By default we support CSS Modules with the extension .module.css
        ...createStyleLoaders(MiniCssExtractPlugin.loader, {
          emit: false
        }),
        {
          test: /\.mdx?$/,
          use: [
            {
              loader: require.resolve('babel-loader'),
              options: {
                sourceType: 'unambiguous',
                babelrc: false,
                configFile: false,
                presets: [
                  require.resolve('@babel/preset-react'),
                  require.resolve('@babel/preset-env'),
                ],
              },
            },
            {
              loader: require.resolve('@teambit/mdx.modules.mdx-loader'),
            },
          ],
        },
        {
          test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
          type: 'asset',
          parser: {
            dataUrlCondition: {
              maxSize: imageInlineSizeLimit,
            },
          },
          generator: {
            filename: 'static/images/[hash][ext][query]',
          },
        },
        {
          // loads svg as both inlineUrl and react component, like:
          // import starUrl, { ReactComponent as StarIcon } from './star.svg';
          // (remove when there is native support for both opitons from webpack5 / svgr)
          test: /\.svg$/,
          oneOf: [
            {
              dependency: { not: ['url'] }, // exclude new URL calls
              use: [
                {
                  loader: require.resolve('@svgr/webpack'),
                  options: { titleProp: true, ref: true },
                },
                require.resolve('new-url-loader'),
              ],
            },
            {
              type: 'asset', // export a data URI or emit a separate file
            },
          ],
        },
        {
          test: /\.(woff(2)?|ttf|eot|svg)(\?v=\d+\.\d+\.\d+)?$/,
          type: 'asset',
          generator: {
            filename: 'static/fonts/[hash][ext][query]',
          },
        },
      ]
    }
  };
};
