import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer';
import cors from 'cors';
import http from 'node:http';
import express from 'express';
import { buildSubgraphSchema } from '@apollo/subgraph';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServer } from '@apollo/server';
export class DefaultServer {
    // name = 'symphony-server';
    async run(context) {
        const name = context.name;
        const port = context.port || 3000;
        const app = express();
        const httpServer = http.createServer(app);
        // The ApolloServer constructor requires two parameters: your schema
        // definition and your set of resolvers.
        const server = new ApolloServer({
            schema: buildSubgraphSchema({
                typeDefs: context.gql?.typeDefs,
                resolvers: context.gql?.resolvers
            }),
            plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
        });
        await server.start();
        app.use(cors({
            origin(origin, callback) {
                callback(null, true);
            },
            credentials: true,
        }));
        app.use('/graphql', express.json(), 
        // expressMiddleware accepts the same arguments:
        // an Apollo Server instance and optional configuration options
        expressMiddleware(server, {
            context: async ({ req }) => req,
        }));
        context.routes?.forEach((route) => {
            const method = route.method || 'get';
            app[method](route.path, route.route);
        });
        await new Promise((resolve) => httpServer.listen({ port }, resolve));
        return {
            appName: name,
            port,
            url: `http://localhost:${port}`,
            stop: async () => {
                httpServer.closeAllConnections();
                httpServer.close();
            }
        };
    }
}
//# sourceMappingURL=default-server.js.map